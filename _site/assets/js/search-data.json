{"0": {
    "doc": "Access Control",
    "title": "Access Control",
    "content": "CI Fuzz enables you to collaborate with others through organizations and projects. An organization can be a company, team, or any other group of people that are working on the same set of projects. Each project belongs to an organization. ",
    "url": "http://localhost:4000/ci-fuzz-access-control",
    "relUrl": "/ci-fuzz-access-control"
  },"1": {
    "doc": "Access Control",
    "title": "Table of contents",
    "content": ". | Organization Roles | Creating Organizations | Managing Organizations | Customizing Organizations . | Add Custom Logo | Create Custom Color Scheme | . | Project Roles | Creating Projects | . ",
    "url": "http://localhost:4000/ci-fuzz-access-control#table-of-contents",
    "relUrl": "/ci-fuzz-access-control#table-of-contents"
  },"2": {
    "doc": "Access Control",
    "title": "Organization Roles",
    "content": "Organizations have two roles: administrators and members. | Administrators have complete administrative access to the organization. | Members are the default for everybody else. The project role that members gain in a project within an organization is configurable by the administrator. | . Capabilities of each organization role: . | Organization action | Member | Administrator | . | List org members |   | X | . | Add member to org |   | X | . | Remove member from org |   | X | . | Delete Org |   | X | . | Manage member permissions |   | X | . | View member permissions |   | X | . | View all org projects | X | X | . | Add project to org | X* | X | . * organization members can only perform the Add project to org action if the default project role is Developer or Administrator. ",
    "url": "http://localhost:4000/ci-fuzz-access-control#organization-roles",
    "relUrl": "/ci-fuzz-access-control#organization-roles"
  },"3": {
    "doc": "Access Control",
    "title": "Creating Organizations",
    "content": "To create an organization: . | Login to CI Fuzz | On the left sidebar select Organizations. This will open a new pane listing all the current organizations you belong to. | On the new pane in the top right click NEW ORGANIZATION. | Select the Add manually option by clicking + ADD. | Enter your desired organization name and click + ADD. | . ",
    "url": "http://localhost:4000/ci-fuzz-access-control#creating-organizations",
    "relUrl": "/ci-fuzz-access-control#creating-organizations"
  },"4": {
    "doc": "Access Control",
    "title": "Managing Organizations",
    "content": "Organization management features are accessible by selecting Organizations from the left sidebar and then selecting the appropriate organization. The creator of an organization is an organization administrator and can manage members of the organization. For a given organization, an organization administrator can set the default role for project members. This option is located under the GENERAL tab in the organization pane. Note: All members of an organization will have this role across all projects. Under the MEMBERS tab in the organization pane, organization administrators can add and remove members from the organization. They can also promote other members to administrators. Note: To add a member this way, they must have logged in to CI Fuzz at least once. ",
    "url": "http://localhost:4000/ci-fuzz-access-control#managing-organizations",
    "relUrl": "/ci-fuzz-access-control#managing-organizations"
  },"5": {
    "doc": "Access Control",
    "title": "Customizing Organizations",
    "content": "Visual aspects of each organization can be customized to suit your preferences. After you have created your organization, The options below are all available under a specific organization’s settings provided you are an organization administrator. Add Custom Logo . You can add a logo for a specific organization. Whenever someone is interacting with this organization, the logo in the top left of the UI will be the one you applied. You can set a different logo for light mode and dark mode. The appropriate logo will be displayed based on the mode a user has specified in their user settings. Create Custom Color Scheme . You can specify a custom color scheme for the UI. Similarly to logos, you can specify a color scheme for an organization based on which mode a user has specified, either light mode or dark mode. Colors can be selected using a color palette by clicking on one of the colored boxes or specifying the appropriate hex code. When selecting with the color palette, you can click SAVE COLOR in the popup box to preview the color. Colors will not be permanently saved until you select SAVE SETTINGS in the bottom right. You can restore the default color scheme at any time by clicking RESET and then SAVE SETTINGS. ",
    "url": "http://localhost:4000/ci-fuzz-access-control#customizing-organizations",
    "relUrl": "/ci-fuzz-access-control#customizing-organizations"
  },"6": {
    "doc": "Access Control",
    "title": "Project Roles",
    "content": "Projects have the following roles: . | Observers have read-only access to a project. | Developers have read-write access to a project. | Administrators have full access to a project. | . Capabilities of each project role: . | Project Action | Observer | Developer | Administrator | . | View Findings | X | X | X | . | Download Report | X | X | X | . | Start Fuzzing |   | X | X | . | Configure Fuzzing |   | X | X | . | Configure Project |   | X | X | . | Delete Findings |   |   | X | . | Delete Project |   |   | X | . | List Members |   |   | X | . | Add Members |   |   | X | . | Delete Members |   |   | X | . ",
    "url": "http://localhost:4000/ci-fuzz-access-control#project-roles",
    "relUrl": "/ci-fuzz-access-control#project-roles"
  },"7": {
    "doc": "Access Control",
    "title": "Creating Projects",
    "content": "There are two ways to add a project: . | Go to the PROJECTS tab for an organization you are a member of and click ADD PROJECT. | From the left sidebar, under PROJECTS, click the Select Project dropdown menu and select Add Project. | . For either method, an Add Project windows pops up where you can specify: . | Project name | Organization (required) | Git URL (HTTPS, .git) (required) | Description | . ",
    "url": "http://localhost:4000/ci-fuzz-access-control#creating-projects",
    "relUrl": "/ci-fuzz-access-control#creating-projects"
  },"8": {
    "doc": "Authentication",
    "title": "Authentication",
    "content": "This page describes the different ways to configure authentication to CI Fuzz Web Application. CI Fuzz supports OAuth, OIDC, and password based logins. ",
    "url": "http://localhost:4000/ci-fuzz-authentication",
    "relUrl": "/ci-fuzz-authentication"
  },"9": {
    "doc": "Authentication",
    "title": "Table of contents",
    "content": ". | OAuth | OIDC . | Create an OIDC-capable application | Configure CI Fuzz Server | . | Password | . ",
    "url": "http://localhost:4000/ci-fuzz-authentication#table-of-contents",
    "relUrl": "/ci-fuzz-authentication#table-of-contents"
  },"10": {
    "doc": "Authentication",
    "title": "OAuth",
    "content": "To use SSO with GitHub, Bitbucket, or GitLab you need to create an OAuth app. GitHub . | Open the developer settings | Click Register a new application. | For the Authorization callback URL, use https://&lt;fuzzing_server_domain&gt;/auth/github/callback. | After registering the application, GitHub will generate a Client ID and Client Secret. Open /etc/cifuzz/config.env and copy these values toCIFUZZ_GITHUB_CLIENT_ID and CIFUZZ_GITHUB_CLIENT_SECRET respectively. | . Bitbucket.org . | Go to bitbucket cloud and select the appropriate workspace | Click Settings | Under Apps and features, select OAuth consumers and click Add consumer. | As the callback url, use https://&lt;fuzzing_server_domain&gt;:&lt;port&gt;/auth/github/callback. Note: The port is mandatory, even if it’s the default port 443. | Give it the email and read permissions in the Account section and then save it. | Expand the section for the consumer you just created to show the Key and Secret. | Open /etc/cifuzz/config.env and copy these values toCIFUZZ_BITBUCKET_CLIENT_ID and CIFUZZ_BITBUCKET_CLIENT_SECRET respectively. | . GitLab . | Go to Preferences and click Applications. | Choose a name and set the Redirect URI to https://&lt;fuzzing_server_domain&gt;/auth/github/callback. | Enable the read_user scope. | Click Save application and then select the application from Your applications. | Open /etc/cifuzz/config.env and copy Application ID and Secret toCIFUZZ_GITLAB_CLIENT_ID and CIFUZZ_GITLAB_CLIENT_SECRET respectively. | . ",
    "url": "http://localhost:4000/ci-fuzz-authentication#oauth",
    "relUrl": "/ci-fuzz-authentication#oauth"
  },"11": {
    "doc": "Authentication",
    "title": "OIDC",
    "content": "This section describes to setup your own OIDC provider with CI Fuzz. Create an OIDC-capable application . In the OIDC provider, create an OIDC-capable application with: . | Redirect URL: &lt;baseURL&gt;/auth/&lt;provider&gt;/callback, where: . | &lt;baseURL&gt; is the URL that the CI Fuzz web app is available at, for example https://cifuzz.example.com. | &lt;provider&gt; is a name of your choice, that will be used for this OIDC provider in the CI Fuzz web app. | . | If configurable at the provider, permissions that allow reading user profile information, like the name and email address, via OIDC. | . Take note of the application’s client ID and client secret, you need those below. Configure CI Fuzz Server . If the OIDC provider implements the OpenID Connect Discovery spec (i.e. a JSON document exists at .well-known/openid-configuration), the setup is simpler. In that case, create the file /etc/cifuzz/oidc.yaml as: . auth:   oidc:     &lt;provider&gt;:       id: &lt;client ID&gt;       secret: &lt;client secret&gt;       issuer_url: &lt;issuer URL&gt; . … where: . | &lt;provider&gt; is the name for the OIDC provider you chose above. | &lt;client ID&gt; and are the client ID and secret of the application you created above. | &lt;issuer URL&gt; is the base URL of the OIDC provider, for example https://gitlab.com. | . If the OIDC provider does not support OpenID Connect Discovery, add these settings to the configuration file instead: . auth:   oidc:     &lt;provider&gt;:       id: &lt;client ID&gt;       secret: &lt;client secret&gt;       auth_endpoint: &lt;auth endpoint URL&gt;       token_endpoint: &lt;token endpoint URL&gt;       userinfo_endpoint: &lt;UserInfo endpoint URL&gt;       jwks_url: &lt;JWKS URL&gt; . … where: . | &lt;provider&gt; is the name for the OIDC provider you chose above. | &lt;client ID&gt; and &lt;client secret&gt; are the client ID and secret of the application you created above. | &lt;auth endpoint URL&gt; is the URL of the authorization endpoint of the OIDC provider, for example https://gitlab.com/oauth/authorize. | &lt;token endpoint URL&gt; is the URL of the token endpoint of the OIDC provider, for example https://gitlab.com/oauth/token. | &lt;UserInfo endpoint URL&gt; is the URL of the UserInfo endpoint of the  OIDC provider, for example https://gitlab.com/oauth/userinfo. | This setting is optional. If no UserInfo endpoint is specified, only the Claims of the ID Token will be used. | . | &lt;JWKS URL&gt; is the URL of the OIDC provider’s JSON Web Key Set document, for example https://gitlab.com/oauth/discovery/keys. | . ",
    "url": "http://localhost:4000/ci-fuzz-authentication#oidc",
    "relUrl": "/ci-fuzz-authentication#oidc"
  },"12": {
    "doc": "Authentication",
    "title": "Password",
    "content": "If you are just trying out CI Fuzz, it may be more convenient to use a password as the authentication method. In /etc/cifuzz/cifuzz.env there are two options you need to set: . | CIFUZZ_ENABLE_PASSWORD_LOGIN=1 | DEMO_ORG_ADMIN_TOKEN=&lt;your_password_here&gt; | . Note: This is not the recommended authentication approach for CI Fuzz with multiple users. Password authentication is only intended for initial testing and setup until you are ready to implement OAuth. ",
    "url": "http://localhost:4000/ci-fuzz-authentication#password",
    "relUrl": "/ci-fuzz-authentication#password"
  },"13": {
    "doc": "Findings",
    "title": "Findings",
    "content": "This section contains information about findings in CI Fuzz. How to access them, how they are categorized, and ways CI Fuzz can help with managing them. ",
    "url": "http://localhost:4000/ci-fuzz-findings",
    "relUrl": "/ci-fuzz-findings"
  },"14": {
    "doc": "Findings",
    "title": "Table of contents",
    "content": ". | Findings Overview | Severity | Managing Findings . | Findings Overview | Finding Status | Finding Details | . | . ",
    "url": "http://localhost:4000/ci-fuzz-findings#table-of-contents",
    "relUrl": "/ci-fuzz-findings#table-of-contents"
  },"15": {
    "doc": "Findings",
    "title": "Findings Overview",
    "content": "Findings for a specific project can be viewed by clicking on Findings on the left sidebar. For a given run, CI Fuzz will display the total number of findings and the quantities for each severity (Cricital, High, Medium, and Low). These can be selected to filter for the findings you are most interested in viewing. There may also be categories depending on the specific findings that were discovered during the fuzz run. ",
    "url": "http://localhost:4000/ci-fuzz-findings#findings-overview",
    "relUrl": "/ci-fuzz-findings#findings-overview"
  },"16": {
    "doc": "Findings",
    "title": "Severity",
    "content": "Each finding discovered by CI Fuzz will have a severity score, a numerical score in the range 0.1 - 10.0 and an associated classification. The severity score and severity classification use the same values as CVSS to enable you to easily integrate with other processes and tools that recognize this standard. | Severity Score | Severity Classification | . | 0.1 - 3.9 | Low | . | 4.0 - 6.9 | Medium | . | 7.0 - 8.9 | High | . | 9.0 - 10.0 | Critical | . Source of Severity . The severity score and severity classification provided by CI Fuzz represent the importance of a finding. This score is based on the nature of the bug or vulnerability in a generic context. The score does not account for the specifics of a given vulnerability such as the number of versions affected, ease of exploitation, etc. Finding Categories . Findings may have additional categories indicating it belongs to a group of findings. These categories are: . | OWASP - the finding is included in the OWASP Top 10. | External - the finding using the fuzzer input was confirmed by ZAP. These findings, since they are based solely off the input and not triggered by the fuzzer, will not contain a detailed stack trace or line numbers. | Regression - the finding had been marked as fixed but has now reoccurred. False positives may occur if not all tests have been executed in the current or previous run or if tests have been modified. | API - A finding with an “API” category was found by a Web API fuzzing test. Depending on the availability of the API under test, this type of issue may be one that can be readily exploitable by anyone with the same access. | . ",
    "url": "http://localhost:4000/ci-fuzz-findings#severity",
    "relUrl": "/ci-fuzz-findings#severity"
  },"17": {
    "doc": "Findings",
    "title": "Managing Findings",
    "content": "CI Fuzz provides capabilities to help you manage your findings so you can properly triage, track, and ultimately fix them. Findings Overview . There are three you can see an overview of current findings for a given project: . | The Dashboard will contain the available project cards. This can be found in the left pane near the top. | Select the project from the dropdown menu in the left pane (just below Dashboard) and then click either Overview or Findings in the left pane. | . The overview provides a clear view of: . | The current number of findings, total and new. | The severity classification of these findings. | The categories associated with the findings. | . You can click on the severity classification or one of the categories to quickly filter for the findings you consider highest priority. Clicking on one of the filters or on the project pane itself will show you the list of findings. Click a specific finding to obtain additional information. Finding Status . A finding can have 1 of 3 different states: Open, Assessed, or Ignored. You can adjust these by selecting the Action dropdown on the right side. | An open finding indicates this finding has not been processed in any way. If the fuzzer discovers this finding in the future, it will be reported again. | An assessed finding is one that is currently being analyzed. Assessed findings prevent the fuzzing run from failing when they are rediscovered, but will still alert the user they were found. | ignored status is for any findings you consider should not be fixed for whatever reason. The fuzzer will not report this finding if it encounters it again. | . Type and ID . The type of the finding (Stack Buffer Overflow, Sql Injection, etc…) and an identifier used by CI Fuzz. Location . This column will contain the location where the fuzzer discovered the finding. Download Findings . You can download the findings as a pdf, Word document, or Excel document. Click on the that is located just above the actual findings. Link to Ticket System . CI Fuzz can link to external ticket systems to help manage the remediation process for a finding. Under the Action menu on the right of the finding, click , paste the URL of the created issue (from Jira, GitHub, etc…) and click Link. Finding Details . When you expand a finding in the bottom pane (by clicking the &gt; on the left side of a finding), it will contain 3 tabs with different information: Debug, Description, and Log. These tabs contain several pieces of information that can help you determine the root cause of the finding. | The debug tab contains the fuzz test responsible for the finding, the source line, the stack trace (if available), and the crashing input. | The description tab contains the severity score, a short description of the finding, and possibly some links to additional information about this type of finding. | The log tab content depends on the type of fuzzing that discovered the finding. If the finding is from unit fuzzing, then the output will be output directly from the fuzzer. If the finding is from Web API fuzzing, then the output will contain the API request responsible for triggering the finding. | . ",
    "url": "http://localhost:4000/ci-fuzz-findings#managing-findings",
    "relUrl": "/ci-fuzz-findings#managing-findings"
  },"18": {
    "doc": "Running a Fuzz Test",
    "title": "Running a Fuzz Test with CI Fuzz",
    "content": "This page describes how to run a fuzz test on CI Fuzz, both manually and as part of a CI/CD pipeline. ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test#running-a-fuzz-test-with-ci-fuzz",
    "relUrl": "/ci-fuzz-running-a-fuzz-test#running-a-fuzz-test-with-ci-fuzz"
  },"19": {
    "doc": "Running a Fuzz Test",
    "title": "Table of contents",
    "content": ". | Create a Bundle with CI Fuzz CLI . | Drag and Drop Bundle | Import and Start with cictl | . | CI Fuzz CLI Remote Run | Running Fuzz Tests with CI/CD | . ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test#table-of-contents",
    "relUrl": "/ci-fuzz-running-a-fuzz-test#table-of-contents"
  },"20": {
    "doc": "Running a Fuzz Test",
    "title": "Create a Bundle with CI Fuzz CLI",
    "content": "If you’re project is already configured with CI Fuzz CLI, you can create a bundle by running the following command from the root of the project directory: . cifuzz bundle . | This command will build and bundle the runtime artifacts needed to run your fuzz test(s) on a CI Fuzz server | You can specify the name of one or more fuzz tests or don’t specify any to build all the fuzz tests for a project | You can specify various arguments that will tell CI Fuzz how to run your fuzz tests. See this page for additional details. | The output is a tarball of the form fuzz_tests.tar.gz or &lt;name_of_specific_fuzz_test&gt;.tar.gz if you specified one. | . Drag and Drop Bundle . Once you have created your bundle, you can drag and drop it in the Web UI on the project card you want to run it under. You can either do this from the Dashboard or from the Overview after selecting your project. Import and Start with cictl . Once you have created a bundle, you can also use the cictl command (located in ci-fuzz-install-directory/bin/cictl) to upload the bundle to the CI Fuzz server and then start it. Here are the cictl commands you can use to accomplish this . FUZZING_SERVER=\"&lt;address of fuzzing server&gt;\" PROJECT=\"&lt;project name&gt;\" CICTL_CMD=\"cictl -s $FUZZING_SERVER\" ARTIFACT_NAME=$($CICTL_CMD import artifact fuzz_tests.tar.gz --project-name \"$PROJECT\") $CICTL_CMD start ${ARTIFACT_NAME} . | Most cictl commands require the --server, -s flag to specify the location of the fuzzing server, so be sure to include it | The project name can be obtained by running cictl -s &lt;fuzzing server&gt; list projects. The project name should be of the form projects/my_project-391A177B. | . ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test#create-a-bundle-with-ci-fuzz-cli",
    "relUrl": "/ci-fuzz-running-a-fuzz-test#create-a-bundle-with-ci-fuzz-cli"
  },"21": {
    "doc": "Running a Fuzz Test",
    "title": "CI Fuzz CLI Remote Run",
    "content": "You can use the CI Fuzz CLI remote-run command (cifuzz remote-run) to bundle, submit, and start your fuzz tests with one command. This method does not require cictl. cifuzz remote-run --server &lt;server address&gt; . | You can authenticate to the server automatically by passing the environment variable CIFUZZ_API_TOKEN as part of your command (e.g. CIFUZZ_API_TOKEN=&lt;token&gt; cifuzz remote-run --server \"https://cifuzz.server.com\"). | You can specify the name of one or more fuzz tests. If you or don’t specify any, then remote-run will bundle and run all the fuzz tests for a project. | You can specify various arguments that will tell CI Fuzz how to run your fuzz tests. See this page for additional details. | You can pass an existing bundle by simply specifying the --bundle flag and the path to the bundle. When passing an existing bundle, CI Fuzz will ignore any runtime flags passed as part of the remote-run command (e.g. --timeout, --docker-image). | . ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test#ci-fuzz-cli-remote-run",
    "relUrl": "/ci-fuzz-running-a-fuzz-test#ci-fuzz-cli-remote-run"
  },"22": {
    "doc": "Running a Fuzz Test",
    "title": "Running Fuzz Tests with CI/CD",
    "content": "To create a CI/CD pipeline, you will need to install both CI Fuzz CLI and the cictl command line tool. CI Fuzz must be reachable from the CI/CD server. The general workflow is . | Build/bundle the artifacts that will run on the server | Upload the artifacts to the server and run them | Monitor the results | . Here is a script you can use to help write and test your CI/CD pipeline. #! /usr/bin/bash # how long to monitor the fuzz test TIMEOUT=300 # this should match wherever CI Fuzz is currently reachable FUZZING_SERVER=\"127.0.0.1:8080\" # address of the web application WEB_APP_ADDRESS=\"http://127.0.0.1:8080\" # project name of the form: projects/c-cpp-demo-0b5fbe28 # this can be obtained by using cictl -s &lt;server&gt; list projects PROJECT=&lt;project name&gt; # access token generated in the CI Fuzz web app CI_FUZZ_API_TOKEN= # local directory where the project is located LOCAL_REPO= # create bundle from local repo # you can specify additional bundle options at the command line, or include them in cifuzz.yaml cd $LOCAL_REPO cifuzz bundle CICTL_CMD=\"cictl -s $FUZZING_SERVER\" # login to the CI Fuzz server echo $CI_FUZZ_API_TOKEN | $CICTL_CMD login # upload the bundle to the CI Fuzz server ARTIFACT_NAME=$($CICTL_CMD import artifact fuzz_tests.tar.gz --project-name \"$PROJECT\") # start the fuzz tests in the bundle CAMPAIGN_RUN=$($CICTL_CMD start --application-base-url \"${WEB_APP_ADDRESS}\" \"${ARTIFACT_NAME}\") # monitor the output from the campaign_run $CICTL_CMD monitor_campaign_run --dashboard_address=\"${WEB_APP_ADDRESS}\" --keep_running --duration=\"${TIMEOUT}\" ${CAMPAIGN_RUN} . ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test#running-fuzz-tests-with-cicd",
    "relUrl": "/ci-fuzz-running-a-fuzz-test#running-fuzz-tests-with-cicd"
  },"23": {
    "doc": "Running a Fuzz Test",
    "title": "Running a Fuzz Test",
    "content": " ",
    "url": "http://localhost:4000/ci-fuzz-running-a-fuzz-test",
    "relUrl": "/ci-fuzz-running-a-fuzz-test"
  },"24": {
    "doc": "Coverage",
    "title": "Coverage",
    "content": "This section explains how cifuzz can generate and visualize coverage reports. cifuzz can also be integrated directly with the IDEs CLion and VSCode. ",
    "url": "http://localhost:4000/cli-coverage",
    "relUrl": "/cli-coverage"
  },"25": {
    "doc": "Coverage",
    "title": "Table of contents",
    "content": ". | Generating Coverage Reports | IDE Integrations . | CLion | VS Code | . | . ",
    "url": "http://localhost:4000/cli-coverage#table-of-contents",
    "relUrl": "/cli-coverage#table-of-contents"
  },"26": {
    "doc": "Coverage",
    "title": "Generating Coverage Reports",
    "content": "After running a fuzz test, you can generate a coverage report which shows the line by line coverage of the fuzzed code. It does this by executing the target software with all inputs in the corpus. cifuzz coverage my_fuzz_test . Running the above command will create the coverage report and automatically launch your browser to view it. This will show coverage of the fuzz test itself, as well as the relevant source files. We’ll focus on coverage of the exploreMe function in explore_me.cpp here. The count column shows the number of times the fuzz test reached a given line in the source code. The line counts decrease as the fuzz test finds new inputs to reach deeper parts of the code until it triggers a heap-buffer-overflow. ",
    "url": "http://localhost:4000/cli-coverage#generating-coverage-reports",
    "relUrl": "/cli-coverage#generating-coverage-reports"
  },"27": {
    "doc": "Coverage",
    "title": "IDE Integrations",
    "content": "cifuzz can be integrated with existing IDEs. Below are examples for CLion and VS Code. CLion . You can start coverage runs from within CLion with the help of CMake user presets. Custom cifuzz presets can be added by running: . cifuzz integrate cmake . Those presets have to be enabled before they show up as a run configuration. See here for more details. VS Code . You can start coverage runs from within VS Code with the help of tasks. See here for more details. A custom cifuzz coverage task can be added by running: . cifuzz integrate vscode . Coverage reports can be visualized with the Coverage Gutters extension. ",
    "url": "http://localhost:4000/cli-coverage#ide-integrations",
    "relUrl": "/cli-coverage#ide-integrations"
  },"28": {
    "doc": "Creating a Fuzz Test",
    "title": "Creating a Fuzz Test",
    "content": "This section describes how to create a fuzz test using the CI Fuzz CLI. It covers the cifuzz create command and provides details needed to integrate cifuzz with specific build systems. ",
    "url": "http://localhost:4000/cli-creating-a-fuzz-test",
    "relUrl": "/cli-creating-a-fuzz-test"
  },"29": {
    "doc": "Creating a Fuzz Test",
    "title": "Table of contents",
    "content": ". | Overview | C/C++ . | CMake | Bazel | Make | Meson | . | Java . | Maven | Gradle | . | . ",
    "url": "http://localhost:4000/cli-creating-a-fuzz-test#table-of-contents",
    "relUrl": "/cli-creating-a-fuzz-test#table-of-contents"
  },"30": {
    "doc": "Creating a Fuzz Test",
    "title": "Overview",
    "content": "The cifuzz create command creates a fuzz test template you can use to start writing a fuzz test. Depending on the language and build system you are using, you may also need to modify some build system configuration files. These are detailed below. ",
    "url": "http://localhost:4000/cli-creating-a-fuzz-test#overview",
    "relUrl": "/cli-creating-a-fuzz-test#overview"
  },"31": {
    "doc": "Creating a Fuzz Test",
    "title": "C/C++",
    "content": ". CMake . Run the following cifuzz command: . cifuzz create cpp -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. After creating your fuzz test, you need to add the add_fuzz_test and target_link_libraries commands to your CMakeLists.txt file so CMake can find, build, and link your fuzz test. Add the following to your CMakeLists.txt (with names and paths modified to match your project): . add_fuzz_test(my_fuzz_test test/my_fuzz_test.cpp) target_link_libraries(my_fuzz_test PRIVATE exploreMe) . You can see an example CMakeLists.txt in the cifuzz repo: example CMakeLists.txt file . Bazel . Run the following cifuzz command: . cifuzz create cpp -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. After creating your fuzz test template, you need to define a bazel target by adding the following to the BUILD.bazel file: . load(\"@rules_fuzzing//fuzzing:cc_defs.bzl\", \"cc_fuzz_test\") cc_fuzz_test( name = \"my_fuzz_test\", srcs = [\"my_fuzz_test.cpp\"], corpus = glob( [\"my_fuzz_test_inputs/**\"], allow_empty = True, ), deps = [ \"//src:explore_me\", \"@cifuzz\" ], ) . You can see an example BUILD.bazel in the cifuzz repo: example BUILD.bazel file . Make . While cifuzz provides direct support for C/C++ CMake and Bazel projects, it can generally support several other build systems by allowing you to configure build-commands that enable your project to build the fuzz tests properly. Here is an example for Make. Run the following cifuzz command: . cifuzz create cpp -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. Next, you need to create a target in the Makefile for the fuzz test. To enable building the target as a fuzz test, cifuzz sets the following environment variables: . | CC - Sets the C compiler to clang | CXX - Sets the C++ compiler to clang++ | CFLAGS - Sets the necessary C compiler and linker flags that should be used for the fuzz test and the software under test | CXXFLAGS - Sets the necessary C++ compiler and linker flags that should be used for the fuzz test and the software under test | FUZZ_TEST_CFLAGS - Sets the necessary compiler flags that should be used for the fuzz test | FUZZ_TEST_LD_FLAGS - Sets the necessary linker flags that should be used for the fuzz test | . FUZZ_TEST_CFLAGS and FUZZ_TEST_LDFLAGS are environment variables which must both be passed to the compiler and linker command for the fuzz test. The CC, CXX, CFLAGS, CXXFLAGS variables should be used for both the fuzz test and the software under test. Here are the targets for the software under test (libexplore.so) and the fuzz test from the example project Makefile: . libexplore.so: src/explore_me.cpp src/explore_me.h ${CXX} ${CXXFLAGS} -shared -fpic -o libexplore.so $&lt; my_fuzz_test: libexplore.so ${CXX} ${CXXFLAGS} ${FUZZ_TEST_CFLAGS} ${FUZZ_TEST_LDFLAGS} -o $@ $@.cpp -Wl,-rpath '-Wl,$$ORIGIN' -L. -lexplore . Please make sure you don’t overwrite CFLAGS and CXXFLAGS in your Makefile or included files. CI Fuzz CLI relies on being able to add flags to CFLAGS and CXXFLAGS variables to instrument software under test. If you set these variables to a hardcoded value, you will remove instrumentation. You can check if they are being overwritten for example with this command: . grep -Ri -e CFLAGS*[^+]= -e CXXFLAGS*[^+]= . You can then adjust your Makefile to preserve options set by CI Fuzz CLI: . CXXFLAGS += &lt;your options&gt; . You can see an example Makefile in the cifuzz repo: example Makefile . Meson . While cifuzz provides direct support for C/C++ CMake and Bazel projects, it can generally support several other build systems by allowing you to configure build-commands that enable your project to build the fuzz tests properly. Here is an example for Meson. Run the following cifuzz command: . cifuzz create cpp -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. To enable building the target as a fuzz test, cifuzz sets the following environment variables: . | CC - Sets the C compiler to clang | CXX - Sets the C++ compiler to clang++ | CFLAGS - Sets the necessary C compiler and linker flags that should be used for the fuzz test and the software under test | CXXFLAGS - Sets the necessary C++ compiler and linker flags that should be used for the fuzz test and the software under test | FUZZ_TEST_CFLAGS - Sets the necessary compiler flags that should be used for the fuzz test | FUZZ_TEST_LD_FLAGS - Sets the necessary linker flags that should be used for the fuzz test | . FUZZ_TEST_CFLAGS and FUZZ_TEST_LDFLAGS are environment variables which must both be passed to the compiler and linker command for the fuzz test. The CC, CXX, CFLAGS, CXXFLAGS variables should be used for both the fuzz test and the software under test. For Meson, you need to: . | make the cifuzz ENV variables accessible by creating meson variables in meson.build. | add global compiler and linker arguments | link the fuzz test you create with the library you want to fuzz | . Examples for each of the above points: . # make cifuzz ENV variables accessible as meson variables cmd = run_command('sh', '-c', 'echo $FUZZ_TEST_CFLAGS') FUZZ_TEST_CFLAGS = cmd.stdout().strip().strip('\\'') cmd = run_command('sh', '-c', 'echo $FUZZ_TEST_LDFLAGS') FUZZ_TEST_LDFLAGS = cmd.stdout().strip().strip('\\'') cmd = run_command('sh', '-c', 'echo $CFLAGS') CFLAGS = cmd.stdout().strip().strip('\\'').split(' ') cmd = run_command('sh', '-c', 'echo $LDFLAGS') LDFLAGS = cmd.stdout().strip().strip('\\'').split(' ') # add global compiler and linker arguments add_global_arguments(CFLAGS, language: 'cpp') add_global_link_arguments(LDFLAGS, language: 'cpp') # link the fuzz test you created with the target library executable('my_fuzz_test', 'my_fuzz_test.cpp', link_with: [explore_me_shared_lib], cpp_args: [FUZZ_TEST_CFLAGS], link_args: FUZZ_TEST_LDFLAGS ) . Please make sure you don’t overwrite these variables later on, as that would remove flags added by CI Fuzz CLI. You can see a complete meson.build example (and project) in this repo: example meson.build file . ",
    "url": "http://localhost:4000/cli-creating-a-fuzz-test#cc",
    "relUrl": "/cli-creating-a-fuzz-test#cc"
  },"32": {
    "doc": "Creating a Fuzz Test",
    "title": "Java",
    "content": ". Maven . To create the fuzz test template for a Java Maven project, you just need to run the following command: . cifuzz create java -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. Fuzz tests for Maven projects do not require any further configuration of Maven itself. You can see an example fuzz test for a Maven project in the cifuzz repo: example Maven fuzz test . Gradle . To create the fuzz test template for a Java Gradle project, you just need to run the following command: . cifuzz create java -o &lt;path to fuzz test&gt; . This will create a fuzz test template in the location you specify. We recommend creating your fuzz tests close to the code being tested, just as you would for a unit test. Fuzz tests for Gradle projects do not require any further configuration of Gradle itself. You can see an example fuzz test for a Gradle project in the cifuzz repo: example Gradle fuzz test . ",
    "url": "http://localhost:4000/cli-creating-a-fuzz-test#java",
    "relUrl": "/cli-creating-a-fuzz-test#java"
  },"33": {
    "doc": "Findings",
    "title": "Findings",
    "content": "cifuzz provides a high-level summary of the findings. This allows the user to more easily understand what was found during a run. If you want more information about a finding, you can invoke a command to show all details of a finding. The findings used here are from the examples/cmake project in the cifuzz repo. To generate them just clone the cifuzz repo, navigate to examples/cmake and execute cifuzz run my_fuzz_test. ",
    "url": "http://localhost:4000/cli-findings",
    "relUrl": "/cli-findings"
  },"34": {
    "doc": "Findings",
    "title": "Table of contents",
    "content": ". | Listing Findings | Viewing Finding Details | . ",
    "url": "http://localhost:4000/cli-findings#table-of-contents",
    "relUrl": "/cli-findings#table-of-contents"
  },"35": {
    "doc": "Findings",
    "title": "Listing Findings",
    "content": "When cifuzz discovers a finding it stores it in the .cifuzz-findings directory in the project root. To view all findings discovered by cifuzz, just use cifuzz finding. This will provide a list containing the name and type of each finding discovered so far for the project: . brave_jaguar heap buffer overflow sleepy_chupacabra undefined behaviour . ",
    "url": "http://localhost:4000/cli-findings#listing-findings",
    "relUrl": "/cli-findings#listing-findings"
  },"36": {
    "doc": "Findings",
    "title": "Viewing Finding Details",
    "content": "For more detailed information about a finding, just use cifuzz finding &lt;finding_name&gt;. To examine the heap buffer overflow listed above in more detail, run cifuzz finding brave_jaguar. This includes the stack trace and crashing input to help debug the underlying issue. [brave_jaguar] heap buffer overflow Date: 2022-09-28 08:44:16.690423868 +0200 CEST ==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000c51 at pc 0x00000051f94a bp 0x7ffc91b92ef0 sp 0x7ffc91b926b8 WRITE of size 9 at 0x602000000c51 thread T0 #0 0x51f949 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x51f949) #1 0x553f03 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x553f03) #2 0x552bd8 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x552bd8) #3 0x552a28 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x552a28) #4 0x459781 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x459781) #5 0x458ec5 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x458ec5) #6 0x45ae67 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x45ae67) #7 0x45b069 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x45b069) #8 0x44ad75 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x44ad75) #9 0x4729c2 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x4729c2) #10 0x7f6da597c0b2 (/lib/x86_64-linux-gnu/libc.so.6+0x240b2) #11 0x41f59d (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x41f59d) 0x602000000c51 is located 0 bytes to the right of 1-byte region [0x602000000c50,0x602000000c51) allocated by thread T0 here: #0 0x52043d (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x52043d) #1 0x553ee2 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x553ee2) #2 0x552bd8 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x552bd8) #3 0x552a28 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x552a28) #4 0x459781 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x459781) #5 0x458ec5 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x458ec5) #6 0x45ae67 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x45ae67) #7 0x45b069 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x45b069) #8 0x44ad75 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x44ad75) #9 0x4729c2 (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x4729c2) #10 0x7f6da597c0b2 (/lib/x86_64-linux-gnu/libc.so.6+0x240b2) SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/demo_user/repos/cifuzz/examples/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x51f949) Shadow bytes around the buggy address: 0x0c047fff8130: fa fa fd fd fa fa 00 03 fa fa fd fd fa fa fd fd 0x0c047fff8140: fa fa fd fd fa fa 00 04 fa fa fd fd fa fa fd fd 0x0c047fff8150: fa fa fd fd fa fa 00 04 fa fa fd fd fa fa fd fd 0x0c047fff8160: fa fa fd fd fa fa 00 05 fa fa 04 fa fa fa fd fd 0x0c047fff8170: fa fa fd fd fa fa fd fd fa fa 00 06 fa fa 00 04 =&gt;0x0c047fff8180: fa fa 00 07 fa fa 00 07 fa fa[01]fa fa fa fa fa 0x0c047fff8190: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff81a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff81b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff81c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fff81d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==1==ABORTING MS: 0 ; base unit: 0000000000000000000000000000000000000000 0x46,0x55,0x5a,0x5a,0x49,0x4e,0x47,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, FUZZING\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff artifact_prefix='/tmp/minijail-out/'; Test unit written to /tmp/minijail-out/crash-6136034a07f6be0a3575747ae9d2aa2fb2453b79 Base64: RlVaWklOR/////////// . ",
    "url": "http://localhost:4000/cli-findings#viewing-finding-details",
    "relUrl": "/cli-findings#viewing-finding-details"
  },"37": {
    "doc": "Initializing a Project",
    "title": "Initializing a Project",
    "content": "This section describes how to initialize a project for use with the CI Fuzz CLI. It covers the cifuzz init command and details needed to integrate cifuzz with a specific build system. ",
    "url": "http://localhost:4000/cli-initializing-a-project",
    "relUrl": "/cli-initializing-a-project"
  },"38": {
    "doc": "Initializing a Project",
    "title": "Table of contents",
    "content": ". | Overview | C/C++ . | CMake | Bazel | Make | Meson | . | Java . | Maven | Gradle | . | . ",
    "url": "http://localhost:4000/cli-initializing-a-project#table-of-contents",
    "relUrl": "/cli-initializing-a-project#table-of-contents"
  },"39": {
    "doc": "Initializing a Project",
    "title": "Overview",
    "content": "The first step to fuzz testing with cifuzz is to initialize the project. Generally, there are two parts to this: . | Run cifuzz init in the root of your project directory. This will create the cifuzz.yaml configuration file in the same directory. | Modify your build system configuration files to support cifuzz. | . Details on how to modify your build system are provided below for each language and build system currently supported. ",
    "url": "http://localhost:4000/cli-initializing-a-project#overview",
    "relUrl": "/cli-initializing-a-project#overview"
  },"40": {
    "doc": "Initializing a Project",
    "title": "C/C++",
    "content": ". CMake . After running cifuzz init in the root directory of your CMake project, you need to add the following commands to your top level CMakeLists.txt file: . find_package(cifuzz NO_SYSTEM_ENVIRONMENT_PATH) enable_fuzz_testing() . Note: These commands must be added before any add_library or add_executable directives, otherwise the targets will not be compiled with the correct instrumentation/build flags. You can see an example CMakeLists.txt in the cifuzz repo: example CMakeLists.txt file . Bazel . After running cifuzz init in the root directory of your Bazel project, you need to add the following to your WORKSPACE file: . load(\"@bazel_tools//tools/build_defs/repo:git.bzl\", \"git_repository\") load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\") http_archive( name = \"rules_fuzzing\", sha256 = \"93353c864968596cfee046ea1ef587ff62eda90dd24d4360c70465376e507982\", strip_prefix = \"rules_fuzzing-2492fd2f37163de8e19ce85061e90a464f3e9255\", urls = [\"https://github.com/bazelbuild/rules_fuzzing/archive/2492fd2f37163de8e19ce85061e90a464f3e9255.tar.gz\"], ) load(\"@rules_fuzzing//fuzzing:repositories.bzl\", \"rules_fuzzing_dependencies\") rules_fuzzing_dependencies() load(\"@rules_fuzzing//fuzzing:init.bzl\", \"rules_fuzzing_init\") rules_fuzzing_init() git_repository( name = \"cifuzz\", branch = \"bazel-support\", remote = \"https://github.com/CodeIntelligenceTesting/cifuzz\", strip_prefix = \"tools/cmake/cifuzz/include/cifuzz\", ) . You can see an example WORKSPACE in the cifuzz repo: example WORKSPACE file . Make . While cifuzz provides direct support for C/C++ CMake and Bazel projects, it can generally support several other build systems by allowing you to configure build-commands that enable your project to build the fuzz tests properly. Here is an example for Make. Start by running cifuzz init in the root directory of your project. Set build-system . After running cifuzz init, you will need to edit cifuzz.yaml. The build-system option should be other: . build-system: other . Set build-command . When the build-system is set to other, then cifuzz will use the build-command in cifuzz.yaml to build the fuzz test. Edit cifuzz.yaml to include a build-command. For example: . build-command: make clean &amp;&amp; make $FUZZ_TEST . You can see an example cifuzz.yaml for a Make project in the cifuzz repo: example cifuzz.yaml . Meson . While cifuzz provides direct support for C/C++ CMake and Bazel projects, it can generally support several other build systems by allowing you to configure build-commands that enable your project to build the fuzz tests properly. Here is an example for Meson. Start by running cifuzz init in the root directory of your project. Set build-system . After running cifuzz init, you will need to edit cifuzz.yaml. The build-system option should be other: . build-system: other . Set build-command . When the build-system is set to other, then cifuzz will use the build-command in cifuzz.yaml to build the fuzz test. Edit cifuzz.yaml to include a build-command. For example: . build-command: \"rm -rf builddir; meson setup builddir; cd builddir; meson compile -v\" . You can see an example cifuzz.yaml for a Meson project in this repo: example cifuzz.yaml . ",
    "url": "http://localhost:4000/cli-initializing-a-project#cc",
    "relUrl": "/cli-initializing-a-project#cc"
  },"41": {
    "doc": "Initializing a Project",
    "title": "Java",
    "content": ". Maven . After running cifuzz init in the root directory of your Maven project, you need to add the following dependencies to your top level pom.xml file: . &lt;dependency&gt; &lt;groupId&gt;com.code-intelligence&lt;/groupId&gt; &lt;artifactId&gt;jazzer-junit&lt;/artifactId&gt; &lt;version&gt;0.13.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; . If you want to generate Jacoco coverage reports, you also need to include the jacoco plugin in pom.xml: . &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.8.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;report&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; . You can see an example pom.xml in the cifuzz repo: example pom.xml file . Gradle . After running cifuzz init in the root directory of your Gradle project, you need to add the following dependencies to your top level build.gradle file: . testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0' testImplementation 'com.code-intelligence:jazzer-junit:0.13.0' . If you want to generate Jacoco coverage reports, you also need to include the jacoco plugin in build.gradle: . id 'jacoco' . You can see an example build.gradle in the cifuzz repo: example build.gradle file . ",
    "url": "http://localhost:4000/cli-initializing-a-project#java",
    "relUrl": "/cli-initializing-a-project#java"
  },"42": {
    "doc": "Installation",
    "title": "Installing CI Fuzz CLI",
    "content": " ",
    "url": "http://localhost:4000/cli-installation#installing-ci-fuzz-cli",
    "relUrl": "/cli-installation#installing-ci-fuzz-cli"
  },"43": {
    "doc": "Installation",
    "title": "Table of contents",
    "content": ". | Installation . | Installation Directories | Prerequisites | . | How to uninstall cifuzz . | Linux / macOS | Windows | . | Building from Source (Linux / macOS) . | Build dependencies: | Test dependencies: | . | . ",
    "url": "http://localhost:4000/cli-installation#table-of-contents",
    "relUrl": "/cli-installation#table-of-contents"
  },"44": {
    "doc": "Installation",
    "title": "Installation",
    "content": "You can get the latest release here or by running our install script: . sh -c \"$(curl -fsSL https://raw.githubusercontent.com/CodeIntelligenceTesting/cifuzz/main/install.sh)\" . If you are using Windows you can download the latest release and execute it. Do not forget to add the installation’s bin directory to your PATH. By default, CI Fuzz CLI gets installed in your home directory under cifuzz. You can customize the installation directory with ./cifuzz_installer -i /target/dir. Installation Directories . Linux/MacOS . When running the installer as a non-root user, files are installed to: . | ~/.local/share/cifuzz (default) or | $XDG_DATA_HOME/cifuzz if $XDG_DATA_HOME is set. | . A symlink to the cifuzz executable is created in ~/.local/bin/cifuzz. When running the installer as root, files are installed to /opt/code-intelligence/cifuzz and a symlink to the cifuzz executable if created in /usr/local/bin/cifuzz. Windows . All files are installed to %APPDATA%/cifuzz with the executable located in %APPDATA%/cifuzz/bin. Prerequisites . Depending on your language / build system of choice cifuzz has different prerequisites: . C/C++ (with CMake) . | CMake &gt;= 3.16 | LLVM &gt;= 11 | . Ubuntu / Debian sudo apt install cmake clang llvm Arch sudo pacman -S cmake clang llvm macOS brew install cmake llvm lcov Windows At least Visual Studio 2022 version 17 is required. choco install cmake llvm C/C++ (with Bazel) . | Bazel &gt;= 5.3.2 | Java JDK &gt;= 8 (e.g. OpenJDK or Zulu) is needed for Bazel's coverage feature. | LLVM &gt;= 11 | lcov | . Ubuntu / Debian sudo apt install clang llvm lcov sudo curl -L https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 -o /usr/local/bin/bazel sudo chmod +x /usr/local/bin/bazel Arch sudo pacman -S clang llvm lcov sudo curl -L https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 -o /usr/local/bin/bazel sudo chmod +x /usr/local/bin/bazel macOS brew install llvm lcov openjdk bazelisk Windows At least Visual Studio 2022 version 17 is required. choco install cmake llvm microsoft-openjdk bazelisk Java with Maven . | Java JDK &gt;= 8 OpenJDK or Zulu | Maven | . Ubuntu / Debian sudo apt install default-jdk maven Arch sudo pacman -S jdk-openjdk maven macOS brew install openjdk maven Windows choco install microsoft-openjdk maven Java with Gradle . | Java JDK &gt;= 8 OpenJDK or Zulu | Gradle | . Ubuntu / Debian sudo apt install default-jdk gradle Arch sudo pacman -S jdk-openjdk gradle macOS brew install openjdk gradle Windows choco install microsoft-openjdk gradle ",
    "url": "http://localhost:4000/cli-installation",
    "relUrl": "/cli-installation"
  },"45": {
    "doc": "Installation",
    "title": "How to uninstall cifuzz",
    "content": "Linux / macOS . Version &lt; 0.7.0 . If you installed cifuzz into the default directory as root: . sudo rm -rf ~/cifuzz /usr/local/share/cifuzz . If you installed cifuzz as a non-root user: . rm -rf ~/cifuzz ~/.cmake/packages/cifuzz . If you installed into a custom installation directory you have to remove that one instead. Version &gt;= 0.7.0 . From version 0.7.0 the default installation directory has changed. If you installed cifuzz as root: . sudo rm -rf /opt/code-intelligence/cifuzz /usr/local/bin/cifuzz /usr/local/share/cifuzz . If you installed cifuzz as a non-root user: . rm -rf \"${XDG_DATA_HOME:-$HOME/.local/share}/cifuzz\" ~/.local/bin/cifuzz ~/.cmake/packages/cifuzz . If you installed into a custom installation directory you have to remove that one instead. Windows . To uninstall cifuzz and delete the corresponding registry entries: . rd /s %APPDATA%/cifuzz reg delete \"HKLM\\Software\\Kitware\\CMake\\Packages\\cifuzz\" /f 2&gt; nul reg delete \"HKCU\\Software\\Kitware\\CMake\\Packages\\cifuzz\" /f 2&gt; nul . ",
    "url": "http://localhost:4000/cli-installation#how-to-uninstall-cifuzz",
    "relUrl": "/cli-installation#how-to-uninstall-cifuzz"
  },"46": {
    "doc": "Installation",
    "title": "Building from Source (Linux / macOS)",
    "content": "If you want the latest version of cifuzz, you can build it from source. Prerequisites . Build dependencies: . | git | go &gt;= 1.18 | libcap | . Test dependencies: . | LLVM &gt;= 14 | make | CMake &gt;= 3.21 | Bazel &gt;= 5.3.2 | Java JDK &gt;= 8 (e.g. OpenJDK or Zulu) | Maven | Gradle &gt;= 4.9 | . Installing required dependencies . Ubuntu / Debian . sudo apt install git make cmake clang llvm golang-go libcap-dev default-jdk maven gradle # install bazelisk sudo curl -L https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 -o /usr/local/bin/bazel sudo chmod +x /usr/local/bin/bazel . Arch . sudo pacman -S git make cmake clang llvm go jdk-openjdk maven gradle # install bazelisk sudo curl -L https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 -o /usr/local/bin/bazel sudo chmod +x /usr/local/bin/bazel . Unfortunately, the Arch libcap package does not include the static libcap library, which is needed to build cifuzz. You have to build it from source instead: . pacman -Sy --noconfirm glibc pam linux-api-headers make diffutils git clone git://git.kernel.org/pub/scm/libs/libcap/libcap.git cd libcap git checkout libcap-2.65 make make install . macOS . brew install git cmake llvm lcov go openjdk maven gradle bazelisk . Note: Unfortunately, there is a bug in Bazel &lt; 6 on macOS. However, if you set the USE_BAZEL_VERSION environment variable, bazelisk will pick that up and use the correct version accordingly. E.g., put this in your .zshrc: . export USE_BAZEL_VERSION=6.0.0-pre.20221020.1 . Add the following to your ~/.zshrc or ~/.bashrc to use the correct version of LLVM: . export PATH=$(brew --prefix)/opt/llvm/bin:$PATH export LDFLAGS=\"-L$(brew --prefix)/opt/llvm/lib\" export CPPFLAGS=\"-I$(brew --prefix)/opt/llvm/include\" . Steps . To build cifuzz from source you have to execute the following steps: . git clone https://github.com/CodeIntelligenceTesting/cifuzz.git cd cifuzz make test make install . To verify the installation we recommend you to start a fuzzing run in one of our example projects: . cd examples/cmake cifuzz run my_fuzz_test . This should stop after a few seconds with an actual finding. ",
    "url": "http://localhost:4000/cli-installation#building-from-source-linux--macos",
    "relUrl": "/cli-installation#building-from-source-linux--macos"
  },"47": {
    "doc": "Remote Run",
    "title": "Remote Run",
    "content": "The cifuzz remote-run command builds fuzz tests, packages all runtime artifacts into a bundle, and uploads that to a remote CI Fuzz server to start a remote fuzzing run. This section covers the components of the remote-run command that are necessary to make it work with your CI Fuzz installation. Note: The cifuzz remote-run command currently only supports C/C++ projects. ",
    "url": "http://localhost:4000/cli-remote-run",
    "relUrl": "/cli-remote-run"
  },"48": {
    "doc": "Remote Run",
    "title": "Requirements",
    "content": "These are the items that must be specified to use cifuzz remote-run with CI Fuzz in a CI/CD pipeline. cifuzz.yaml . The project must have a cifuzz.yaml (created from cifuzz init) with the appropriate build-system files modified. See how to initialize a project for details on how to do that. cifuzz.yaml should have the correct build-system set (e.g. CMake, Bazel). If the build-system is other, a build-command must be specified. This can either be set in cifuzz.yaml or passed as a command line argument using the --build-command flag of remote-run. Docker Image . The bundle requires a docker image to run on CI Fuzz. The default image is “ubuntu:rolling”, but you can also specify your own image by using the --docker-image flag. The docker image you specify should contain the necessary runtime libraries. Project . The project has to be specified, otherwise cifuzz will prompt for it. It is expected that the project was already created on the remote server. Creating a project from scratch using the cifuzz is not supported yet. Use the --project flag to specify the project name (e.g. c-cpp-demo-4c381320). Server . Specify where the CI Fuzz server is located using the --server flag (protocol://domain:port). Access Token . CI Fuzz requires an access token. Set an environment variable named CIFUZZ_API_TOKEN and assign it a token that was created in the CI Fuzz web application. This token will be stored in ~/.config/cifuzz/access_tokens.json and used on subsequent executions of cifuzz remote-run. Fuzz Test . You must specify the name of 1 or more fuzz tests to be run. ",
    "url": "http://localhost:4000/cli-remote-run#requirements",
    "relUrl": "/cli-remote-run#requirements"
  },"49": {
    "doc": "Running a Fuzz Test",
    "title": "Running a Fuzz Test",
    "content": "This section covers how to run a fuzz test using CI Fuzz CLI. CI Fuzz CLI provides two different approaches to running fuzz tests: running as an actual fuzz test and running as a regression tests. Details for each of these approaches are discussed here. ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test",
    "relUrl": "/cli-running-a-fuzz-test"
  },"50": {
    "doc": "Running a Fuzz Test",
    "title": "Table of contents",
    "content": ". | Running a Fuzz Test | Running a Regression Fuzz Test | CMake | Bazel | . ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test#table-of-contents",
    "relUrl": "/cli-running-a-fuzz-test#table-of-contents"
  },"51": {
    "doc": "Running a Fuzz Test",
    "title": "Running a Fuzz Test",
    "content": "Fuzz tests you have created can be run using cifuzz run &lt;fuzz_test&gt;. When you run a fuzz test this way: . | The fuzzing engine will rapidly generate new inputs to pass to the software under test. | When one of these inputs reaches a new part of the code, it is added to the generated corpus. | The fuzzing run will continue generating new inputs and attempting to improve code coverage until either a crash occurs or the --timeout is reached if you set this value. | When a crash occurs, you will be notified and a finding will be created in a directory named &lt;fuzz_test&gt;_inputs. This directory is created adjacent to the location of the fuzz test. | . ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test",
    "relUrl": "/cli-running-a-fuzz-test"
  },"52": {
    "doc": "Running a Fuzz Test",
    "title": "Running a Regression Fuzz Test",
    "content": "When running as a regression fuzz test, cifuzz will only use existing inputs that are stored in the &lt;fuzz_test&gt;_inputs directory. These are the inputs that previously led to findings. A regression fuzz test will run until all of these inputs are test or a regression (crash) occurs. In this mode, cifuzz will not generate any new inputs, so regression fuzz testing will typically be quite fast and enable you to rapidly check for any regressions. To create a regression fuzz test run, you can: . | Create a replayer binary that can be invoked through the command line. The sections below describe how to create these replayer binaries for different build systems. | Integrate CI Fuzz CLI with your IDE. | . ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test#running-a-regression-fuzz-test",
    "relUrl": "/cli-running-a-fuzz-test#running-a-regression-fuzz-test"
  },"53": {
    "doc": "Running a Fuzz Test",
    "title": "CMake",
    "content": "For CMake projects, you can use the CMake user presets that CI Fuzz CLI provides. These can be generated by running the following command in the root of the project: . cifuzz integrate cmake . This creates a CMakeUserPresets.json in the root directory of the project. With the presets created, you can run regression fuzz tests directly through CMake by using the following: . cmake --preset=\"cifuzz (Regression Test)\" cmake --build --preset=\"cifuzz (Regression Test)\" ctest --preset=\"cifuzz (Regression Test)\" . ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test#cmake",
    "relUrl": "/cli-running-a-fuzz-test#cmake"
  },"54": {
    "doc": "Running a Fuzz Test",
    "title": "Bazel",
    "content": "For Bazel projects, you must add the following configuration to the .bazelrc file in the project workspace: . build:cifuzz-replay --@rules_fuzzing//fuzzing:cc_engine=@rules_fuzzing//fuzzing/engines:replay build:cifuzz-replay --@rules_fuzzing//fuzzing:cc_engine_instrumentation=none build:cifuzz-replay --@rules_fuzzing//fuzzing:cc_engine_sanitizer=asan build:cifuzz-replay --@rules_fuzzing//fuzzing:cc_engine_sanitizer=ubsan build:cifuzz-replay --compilation_mode=opt build:cifuzz-replay --copt=-g build:cifuzz-replay --copt=-U_FORTIFY_SOURCE build:cifuzz-replay --test_env=UBSAN_OPTIONS=halt_on_error=1 . This allows the bazel flag --config=cifuzz-replay to be added to a fuzz test run via bazel test --config=cifuzz-replay. ",
    "url": "http://localhost:4000/cli-running-a-fuzz-test#bazel",
    "relUrl": "/cli-running-a-fuzz-test#bazel"
  },"55": {
    "doc": "CPP Web API Fuzzing",
    "title": "C++ Web API Fuzzing",
    "content": "CI Fuzz is capable of coverage-guided fuzzing for C++ based REST and GRPC APIs. This section will guide you through the initial setup of a C++ Web API fuzzing project. ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#c-web-api-fuzzing",
    "relUrl": "/cpp-web-api-fuzzing#c-web-api-fuzzing"
  },"56": {
    "doc": "CPP Web API Fuzzing",
    "title": "Table of contents",
    "content": ". | Prerequisites | Web API Server | Create a Fuzz Test | Add a Web Service | Compile C++ Bug Detector Framework . | Air Gapped Environments | Build | . | Instrument your Code for Fuzzing . | Running the Instrumented Binary | . | Example Run Script | . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#table-of-contents",
    "relUrl": "/cpp-web-api-fuzzing#table-of-contents"
  },"57": {
    "doc": "CPP Web API Fuzzing",
    "title": "Prerequisites",
    "content": "Before you proceed with this guide, you should have already: . | Installed CI Fuzz and the build tools. | Configured authentication. | Created a project. | Configured your Web API using the template. | Received the C++ bug detector framework from Code Intelligence. | . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#prerequisites",
    "relUrl": "/cpp-web-api-fuzzing#prerequisites"
  },"58": {
    "doc": "CPP Web API Fuzzing",
    "title": "Web API Server",
    "content": "Your Web API can run anywhere as long as it is reachable from the server hosting CI Fuzz. Port details are provided below. Typically, this would be one of the following: . | On the CI/CD server (gitlab/github/jenkins server) | On the CI Fuzz server | A separate server (e.g. your integration testing cluster) | . If you choose to run your Web API on a separate server from the one hosting CI Fuzz, you need to make sure that: . | The Web API is exposed on a network interface and the port on which it is running is reachable from CI Fuzz. | Ports 443 or 80 and 6777-7777 on the server running CI Fuzz are reachable from the server hosting your Web API. | . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#web-api-server",
    "relUrl": "/cpp-web-api-fuzzing#web-api-server"
  },"59": {
    "doc": "CPP Web API Fuzzing",
    "title": "Create a Fuzz Test",
    "content": "You should have already created a fuzz test based on the provided template. ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#create-a-fuzz-test",
    "relUrl": "/cpp-web-api-fuzzing#create-a-fuzz-test"
  },"60": {
    "doc": "CPP Web API Fuzzing",
    "title": "Add a Web Service",
    "content": "CI Fuzz uses the idea of web services to associate fuzz tests to a given service when the fuzzing agent contacts CI Fuzz from the software under test. Web services can be created in the UI with the following steps: . | Open CI Fuzz in your browser | From the left sidebar, select your project from the dropdown menu. | Click Project Settings | Click WEB SEVICES | Click the ADD WEB SERVICE button. | Add a name in the Web Service Identifier textbox. The name/identifier can be whatever you like, but it must match the name in the .code-intelligence/web_services.yaml file. If you used the template project, the name is mywebservice by default. | Click NEXT. | Select C/C++ | If you have not already, you can download the fuzzing agent by clicking DOWNLOAD NATIVE FUZZING AGENT. You can also download the fuzzing agent at any time by running cictl get nativeagent. | If you have not already, you can download the static support library by clicking DOWNLOAD STATIC SUPPORT LIBRARY. You can also download the static support library at any by running cictl get fuzzingsupportlib. | Click DONE | . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#add-a-web-service",
    "relUrl": "/cpp-web-api-fuzzing#add-a-web-service"
  },"61": {
    "doc": "CPP Web API Fuzzing",
    "title": "Compile C++ Bug Detector Framework",
    "content": "The C++ bug detector framework is a framework to hook into C and C++ code with the goal of detecting bugs via CI Fuzz. It is provided as a CMake project so that users can build it with their compiler, using their C++ runtime. The final artifact is a shared object, libhooks.so, which is meant to be preloaded into the application under test. Currently, only Linux is supported. Requirements . | C++ 17+ compiler toolchain. | If detectors with external dependencies are activated during build an internet connection to download them is necessary. | . Air Gapped Environments . If you are building this framework in an airgapped environment, you will need to download the dependencies manually and place them in the folders where CMake expects them. Download all files referenced in CMakeLists.txt by ExternalProject_Add URL and place them in /-prefix/src/external-project-url-downloaded-file&gt;. For the sql-parser dependency this would be build/sql-parser-prefix/src/f0faaad39904f7756d1a8becf798a96e444351d0.zip downloaded from https://github.com/CodeIntelligenceTesting/sql-parser/archive/f0faaad39904f7756d1a8becf798a96e444351d0.zip . Build . mkdir build cd build cmake -DCMAKE_BUILD_TYPE=RELEASE .. cmake --build . Note: Optional detectors will be enabled depending on your build environment. The CMake configuration process reports for each optional detector whether it’s enabled, and why. For example, if you have a license for SQLAPI++, you can enable the SQL injection detector by pointing CMake to your SQLAPI.h using -DCMAKE_INCLUDE_PATH=/path/to/sqlapi/include. External dependency for all detectors: sql-parser . | SQLAPI++ . | Deactivated by default; to enable set -DCMAKE_INCLUDE_PATH=/path/to/sqlapi/include | Tests require SQLAPI++, point CMake to it with -DCMAKE_LIBRARY_PATH=/path/to/sqlapi/lib | . | SQLite . | Enabled by default; to disable set -DENABLE_SQLITE=OFF | libsqlit3 required on build system | . | . After building the framework, you will have the libhooks.so file that you can preload with your application under test when you run it. ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#compile-c-bug-detector-framework",
    "relUrl": "/cpp-web-api-fuzzing#compile-c-bug-detector-framework"
  },"62": {
    "doc": "CPP Web API Fuzzing",
    "title": "Instrument your Code for Fuzzing",
    "content": "Add the following flags to your compilation step: . -fprofile-instr-generate -fcoverage-mapping -fsanitize=fuzzer-no-link -Lpath/to/downloaded/agent -Wl,-rpath,path/to/downloaded/agent -lfuzzing_agent . Add the following flags to your linker step: . -fprofile-instr-generate -fsanitize=fuzzer-no-link -L${CIFUZZ_DIR}/lib/code-intelligence -Wl,-rpath,${CIFUZZ_DIR}/lib/code-intelligence -lfuzzing_agent . Link the static support library with your binary with the following flags: . -Wl,--whole-archive path/to/downloaded/libfuzzing_support_lib.a -Wl,--no-whole-archive . Running the Instrumented Binary . Before you start your fuzz test, you need to start the instrumented binary you created. This binary requires some environment variables so that the agent (libfuzzing_agent.so) knows how to reach CI Fuzz. There are several environment variables you can provide when invoking the instrumented binary. Most of them are required: . | ASAN_OPTIONS=alloc_dealloc_mismatch=0 - deactivates allocation checks that would be triggered in the hook. | LD_PRELOAD - path to the libhooks.so when you built the bug detector framework. This is required. | CIFUZZ_AUTH_TOKEN - API token or password you configured when you configured authentication. | CIFUZZ_SERVICE_NAME - the full web service you added. This can be obtained by running cictl list webservices and copying the appropriate one. Be sure to copy the full path. It should be of the form projects/&lt;project_name&gt;/web_services/&lt;web_service_name&gt;. | CIFUZZ_FUZZING_SERVER_HOST - the IP or domain where CI Fuzz is reachable. | CIFUZZ_FUZZING_SERVER_PORT - the port where CI Fuzz is reachable. | CIFUZZ_TLS - if CI Fuzz is configured with TLS, this should be set to 1. | CIFUZZ_TLS_CERT_FILE - if you are using a custom certificate, specify the path here. | CIFUZZ_HALT_ON_ERROR - a discovered bug does not exit the application by default. If you want the application to halt on errors, set this variable to 1. | . Warning: If TLS is enabled for CI Fuzz and CIFUZZ_TLS is not set to 1, the connection will fail. Example of running the instrumented binary with appropriate environment variables: . ASAN_OPTIONS=alloc_dealloc_mismatch=0 \\ LD_PRELOAD=/home/demo/cpp-bug-detector-framework/build/libhooks.so \\ CIFUZZ_TLS=1 \\ CIFUZZ_AUTH_TOKEN=d24573f2-b6d5-4180-9ce6-9a93872942ad \\ CIFUZZ_SERVICE_NAME=projects/cpp-web-app-4d9d77bd/web_services/cpp-sql-service \\ CIFUZZ_FUZZING_SERVER_PORT=8080 \\ CIFUZZ_FUZZING_SERVER_HOST=127.0.0.1 \\ /home/demo/repos/cpp-web-app/web-app-demo . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#instrument-your-code-for-fuzzing",
    "relUrl": "/cpp-web-api-fuzzing#instrument-your-code-for-fuzzing"
  },"63": {
    "doc": "CPP Web API Fuzzing",
    "title": "Example Run Script",
    "content": "The following is an example run script for running the fuzz tests for a gRPC project. This can also be used as the basis for a CI/CD script to automate the fuzzing process. #! /usr/bin/bash # duration to monitor the campaign run TIMEOUT=120 # type of findings to report FINDINGS_TYPE=CRASH,RUNTIME_ERROR # [IP | DOMAIN]:PORT where CI Fuzz is currently reachable FUZZING_SERVER= # http[s]://[IP | DOMAIN]:PORT where CI Fuzz is currently reachable WEB_APP_ADDRESS= # project name obtained from: cictl list projects PROJECT= # API token (or password) you configured for connecting to CI Fuzz CI_FUZZ_API_TOKEN= # path to the root of the local repository LOCAL_REPO= # [IP | DOMAIN]:PORT where the target API is running SOFTWARE_UNDER_TEST # build the artifacts to submit to CI Fuzz cd $LOCAL_REPO ci-build fuzzers --directory=./ mkdir fuzzing_artifacts # authenticate to the fuzzing server CICTL_CMD=\"cictl -s $FUZZING_SERVER\" echo $CI_FUZZ_API_TOKEN | $CICTL_CMD login # import the artifact bundle to CI Fuzz ARTIFACT_NAME=$($CICTL_CMD import artifact $LOCAL_REPO/fuzzing-artifacts.tar.gz --project-name \"$PROJECT\") # start the fuzz tests TEST_COLLECTION_RUN=$($CICTL_CMD start --application-base-url $SOFTWARE_UNDER_TEST \"${ARTIFACT_NAME}\") # monitor the output of the run $CICTL_CMD monitor_campaign_run --dashboard_address=\"${WEB_APP_ADDRESS}\" --duration=\"${TIMEOUT}\" --findings_type=\"${FINDINGS_TYPE}\" ${TEST_COLLECTION_RUN} . ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing#example-run-script",
    "relUrl": "/cpp-web-api-fuzzing#example-run-script"
  },"64": {
    "doc": "CPP Web API Fuzzing",
    "title": "CPP Web API Fuzzing",
    "content": " ",
    "url": "http://localhost:4000/cpp-web-api-fuzzing",
    "relUrl": "/cpp-web-api-fuzzing"
  },"65": {
    "doc": "Go Web API Fuzzing",
    "title": "Go Web API Fuzzing",
    "content": "CI Fuzz is capable of coverage-guided fuzzing for Go-based REST and GRPC APIs. This section will guide you through the initial setup of a Go Web API fuzzing project. ",
    "url": "http://localhost:4000/go-web-api-fuzzing",
    "relUrl": "/go-web-api-fuzzing"
  },"66": {
    "doc": "Go Web API Fuzzing",
    "title": "Table of contents",
    "content": ". | Prerequisites | Web API Server | Create a Fuzz Test | Add a Web Service | Instrument your code for fuzzing . | Instrument your code with bug detectors | Instrument your code for code coverage | Running the Instrumented Binary | . | Compile Application Protocol Buffers . | Adding Field Hints | . | Example Run Script | . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#table-of-contents",
    "relUrl": "/go-web-api-fuzzing#table-of-contents"
  },"67": {
    "doc": "Go Web API Fuzzing",
    "title": "Prerequisites",
    "content": "Before you proceed with this guide, you should have already: . | Installed CI Fuzz and the build tools. | Configured authentication. | Created a project. | Configured your Web API using the template. | Go version 1.18 or newer | . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#prerequisites",
    "relUrl": "/go-web-api-fuzzing#prerequisites"
  },"68": {
    "doc": "Go Web API Fuzzing",
    "title": "Web API Server",
    "content": "Your Web API can run anywhere as long as it is reachable from the server hosting CI Fuzz. Port details are provided below. Typically, this would be one of the following: . | On the CI/CD server (gitlab/github/jenkins server) | On the CI Fuzz server | A separate server (e.g. your integration testing cluster) | . If you choose to run your Web API on a separate server from the one hosting CI Fuzz, you need to make sure that: . | The Web API is exposed on a network interface and the port on which it is running is reachable from CI Fuzz. | Ports 443 or 80 and 6777-7777 on the server running CI Fuzz are reachable from the server hosting your Web API. | . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#web-api-server",
    "relUrl": "/go-web-api-fuzzing#web-api-server"
  },"69": {
    "doc": "Go Web API Fuzzing",
    "title": "Create a Fuzz Test",
    "content": "You should have already created a fuzz test based on the provided template. ",
    "url": "http://localhost:4000/go-web-api-fuzzing#create-a-fuzz-test",
    "relUrl": "/go-web-api-fuzzing#create-a-fuzz-test"
  },"70": {
    "doc": "Go Web API Fuzzing",
    "title": "Add a Web Service",
    "content": "CI Fuzz uses the idea of web services to associate fuzz tests to a given service when the fuzzing agent contacts CI Fuzz from the software under test. Web services can be created in the UI with the following steps: . | Open CI Fuzz in your browser | From the left sidebar, select your project from the dropdown menu. | Click Project Settings | Click WEB SEVICES | Click the ADD WEB SERVICE button. | Add a name in the Web Service Identifier textbox. The name/identifier can be whatever you like, but it must match the name in the .code-intelligence/web_services.yaml file. If you used the template project, the name is mywebservice by default. | Click NEXT. | Select GO | If you have not already, you can download the fuzzing agent by clicking DOWNLOAD NATIVE FUZZING AGENT. You can also download the fuzzing agent at any time by running cictl get nativeagent. | Click DONE | . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#add-a-web-service",
    "relUrl": "/go-web-api-fuzzing#add-a-web-service"
  },"71": {
    "doc": "Go Web API Fuzzing",
    "title": "Instrument your code for fuzzing",
    "content": "In order to fuzz your application, you first need to instrument the code for fuzzing. This includes adding bug detection capabilities and code coverage instrumentation. Please note that to use the tools we provide for instrumentation, your code should be organized either in the GOPATH directory layout, or using Go modules. If you are using Bazel, you can use the go_path rule here to do that. Instrument your code with bug detectors . We have developed an extensible framework for Go bug detectors that can catch higher-level bugs such as command or template injection while fuzzing (https://github.com/CodeIntelligenceTesting/gofuzz). gofuzz provides a CLI tool to add bug detection capabilities into your Go code. It transforms the source code and replaces calls to functions/methods of interest by calls to corresponding hooks in the github.com/CodeIntelligenceTesting/gofuzz/sanitizers module. By default, gofuzz does not change the code in-place, but generates the instrumented source code in a temporary directory. It produces an overlay file that can be used by Go’s standard build tools. Three steps are needed to instrument bug detection capabilities into your code: . | (Once) Install the gofuzz CLI . go install github.com/CodeIntelligenceTesting/gofuzz/cmd/gofuzz@latest . | (Once) Add the sanitizers package as a dependency for the code base you want to test. This package contains the implementation of the hooks inserted by gofuzz into your code, and therefore must be available when the instrumented code is being compiled. cd &lt;my project&gt; go get -u github.com/CodeIntelligenceTesting/gofuzz/sanitizers@latest . This command also adds the sanitizers package as a dependency in the go.mod file. | Instrument your code using the sanitize subcommand . gofuzz sanitize &lt;package&gt; -o &lt;overlay.json&gt; . This instruments the specified package and writes the instrumented file into a temporary directory. The corresponding file replacements are stored in the file. By default, **gofuzz** writes a file named overlay.json in the current directory. | . Instrument your code for code coverage . In order to fuzz your application, you will need to instrument the code for code coverage. This instrumentation is used to guide the fuzzer so that it generates inputs that maximize code coverage. CI Fuzz provides a command line tool to help with this called ci-gofuzz. The ci-gofuzz tool has several options you can view with ci-gofuzz -h, but here are the recommended options to use: . | -cifuzz_agent_lib - this is the path to the fuzzing agent library (libfuzzing_agent.so). The fuzzing agent is responsible for communicating with the fuzzing server. It can be obtained using the command cictl -s &lt;address of fuzzing server&gt; get nativeagent. This will download the fuzzing agent to the current directory where cictl was executed from. | -cover - this enables source-based coverage instrumentation. This is needed to get a coverage report similar to what you get with go cover | -include - this is a comma separated list of import paths that should be instrumented. If this is not specified, then CI Fuzz will attempt to fuzz all packages with their dependencies. This might result in a loss of performance and generally fuzzing code you may not be interested in. It is recommended you set this to the specific packages you want to fuzz. | -o - name of the output file of the instrumented binary. | -preserve - a comma-separated list of import paths not to instrument for fuzzing. | -race - enable data race detection | -exclude_from_coverage - a comma-separated list of regexes of file paths that should not be instrumented for coverage (e.g. mocks, test helpers). | . You must also specify the package path you want to instrument. Here is an example of running ci-gofuzz against the helloworld grpc server . ci-gofuzz -cifuzz_agent_lib libfuzzing_agent.so -cover -include 'google.golang.org/grpc/examples/helloworld*' -o greeter_server ./helloworld/greeter_server . After running the above command, it will produce an instrumented binary (called greeter_server in this instance). Running the Instrumented Binary . Before you start your fuzz test, you need to start the instrumented binary you created with ci-gofuzz. This binary requires some environment variables so that the agent (libfuzzing_agent.so) knows how to reach CI Fuzz. You should provide the following environment variables when invoking the instrumented binary: . | LD_LIBRARY_PATH - path to the directory containing libfuzzing_agent.so | CIFUZZ_AUTH_TOKEN - API token or password you configured when you configured authentication. | CIFUZZ_SERVICE_NAME - the full web service you added. This can be obtained by running cictl list webservices and copying the appropriate one. Be sure to copy the full path. It should be of the form projects/&lt;project_name&gt;/web_services/&lt;web_service_name&gt;. | CIFUZZ_FUZZING_SERVER_HOST - the IP or domain where CI Fuzz is reachable. | CIFUZZ_FUZZING_SERVER_PORT - the port where CI Fuzz is reachable. | CIFUZZ_TLS - if CI Fuzz is configured with TLS, this should be set to 1. | CIFUZZ_TLS_CERT_FILE - if you are using a custom certificate, specify the path here. | . Warning: If TLS is enabled for CI Fuzz and CIFUZZ_TLS is not set to 1, the connection will fail. Example of running the instrumented binary with appropriate environment variables: . CIFUZZ_TLS=1 \\ CIFUZZ_AUTH_TOKEN=d24573f2-b6d5-4180-9ce6-9a93872942ad \\ LD_LIBRARY_PATH=/home/demo/repos/grpc-go \\ CIFUZZ_SERVICE_NAME=projects/grpc-go-4d9d77bd/web_services/go-grpc-server \\ CIFUZZ_FUZZING_SERVER_PORT=8080 \\ CIFUZZ_FUZZING_SERVER_HOST=127.0.0.1 \\ /home/demo/repos/grpc-go/greeter_server . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#instrument-your-code-for-fuzzing",
    "relUrl": "/go-web-api-fuzzing#instrument-your-code-for-fuzzing"
  },"72": {
    "doc": "Go Web API Fuzzing",
    "title": "Compile Application Protocol Buffers",
    "content": "An essential step of the fuzzing setup of gRPC applications is to compile the protocol buffer files of the application. The most commonly used Interface Definition Language of gRPC applications are Protobuffers. Fuzzing of gRPC applications will target the mutation and transmission of protobuffers. For that reason, the proto buf definitions will be used to generate stubs that can be called by the fuzzer and be used for the mutation of the application’s input data. The protobuffer description files (.proto) of the target application can be compiled with ci-protoc of Code Intelligence: . ci-protoc STUB_OUT_PATH PROTOC_ARGS... STUB_OUT_PATH will be the name of a shared object file that can be used afterwards by the CI-daemon to generate reasonable gRPC input data for the target application. Adding Field Hints . Some applications have authorization or authentication in place which requires to have fixed values to be set in protobuffers sent by client applications. For example, assume there is an access token called “letmein” for a gRPC target service, then the following example ci-protoc command can be used to generate a stub that covers authorized messages during fuzzing. ci-protoc libproto_stub.so -Iproto proto/target_service.proto --field_hint=access_token=let_me_in . Field hints will be used as hints during fuzzing. This means the fuzzer will also fuzz the access_token hint, but sometimes will use the set hint to cover authorized code paths in addition. Note: It is possible to set multiple hint values for the same field if it is reasonable, for example to cover different authorization level of an application. Note: When CI Fuzz uses field hints is essentially non-deterministic. ",
    "url": "http://localhost:4000/go-web-api-fuzzing#compile-application-protocol-buffers",
    "relUrl": "/go-web-api-fuzzing#compile-application-protocol-buffers"
  },"73": {
    "doc": "Go Web API Fuzzing",
    "title": "Example Run Script",
    "content": "The following is an example run script for running the fuzz tests for a gRPC project. This can also be used as the basis for a CI/CD script to automate the fuzzing process. #! /usr/bin/bash # duration to monitor the campaign run TIMEOUT=120 # type of findings to report FINDINGS_TYPE=CRASH,RUNTIME_ERROR # [IP | DOMAIN]:PORT where CI Fuzz is currently reachable FUZZING_SERVER= # http[s]://[IP | DOMAIN]:PORT where CI Fuzz is currently reachable WEB_APP_ADDRESS= # project name obtained from: cictl list projects PROJECT= # API token (or password) you configured for connecting to CI Fuzz CI_FUZZ_API_TOKEN= # path to the root of the local repository LOCAL_REPO= # [IP | DOMAIN]:PORT where the target API is running SOFTWARE_UNDER_TEST # build the artifacts to submit to CI Fuzz cd $LOCAL_REPO ci-build fuzzers --directory=./ # add the libproto_stub.so file to the artifact bundle mkdir fuzzing_artifacts cd fuzzing_artifacts tar -xf ../fuzzing-artifacts.tar.gz cp ../libproto_stub.so work_dir tar -czf ../fuzzing-artifacts.tar.gz * # authenticate to the fuzzing server CICTL_CMD=\"cictl -s $FUZZING_SERVER\" echo $CI_FUZZ_API_TOKEN | $CICTL_CMD login # import the artifact bundle to CI Fuzz ARTIFACT_NAME=$($CICTL_CMD import artifact $LOCAL_REPO/fuzzing-artifacts.tar.gz --project-name \"$PROJECT\") # start the fuzz tests TEST_COLLECTION_RUN=$($CICTL_CMD start --application-base-url $SOFTWARE_UNDER_TEST \"${ARTIFACT_NAME}\") # monitor the output of the run $CICTL_CMD monitor_campaign_run --dashboard_address=\"${WEB_APP_ADDRESS}\" --duration=\"${TIMEOUT}\" --findings_type=\"${FINDINGS_TYPE}\" ${TEST_COLLECTION_RUN} . ",
    "url": "http://localhost:4000/go-web-api-fuzzing#example-run-script",
    "relUrl": "/go-web-api-fuzzing#example-run-script"
  },"74": {
    "doc": "Web API Fuzzing",
    "title": "Web API Fuzzing",
    "content": "CI Fuzz is capable of coverage-guided fuzzing for Java- and Go-based REST and GRPC APIs. This section contains the initial steps you will need to perform to prepare your API for fuzzing. ",
    "url": "http://localhost:4000/web-api-fuzzing",
    "relUrl": "/web-api-fuzzing"
  },"75": {
    "doc": "Web API Fuzzing",
    "title": "Table of contents",
    "content": ". | Download the Template | Template Overview | Configure the Template . | HTTP / REST | gRPC | . | . ",
    "url": "http://localhost:4000/web-api-fuzzing#table-of-contents",
    "relUrl": "/web-api-fuzzing#table-of-contents"
  },"76": {
    "doc": "Web API Fuzzing",
    "title": "Download the Template",
    "content": "Download the following template to the system where you will be building your fuzz tests: . | CI Fuzz Web API Fuzzing Template | . The template contain a directory structure that CI Fuzz needs to start fuzz tests. Depending on the type of API you intend to fuzz, REST or gRPC, will determine the type of modifications you need to make to the configuration files in the template. ",
    "url": "http://localhost:4000/web-api-fuzzing#download-the-template",
    "relUrl": "/web-api-fuzzing#download-the-template"
  },"77": {
    "doc": "Web API Fuzzing",
    "title": "Template Overview",
    "content": "Here is an overview of the key files and directories in the template.code-intelligence/web_services.yaml . The web_services.yaml file lists the different web services you want to fuzz. Each fuzz test must be associated with a web service. If your application consists of several microservices, add one web service entry for each microservice and name them appropriately. Web services can be named however you want as long as they are consistent between the web_services.yaml and &lt;fuzz_test&gt;.yaml files.code-intelligence/fuzz_targets . This folder contains the API fuzz tests. A fuzz test for an API consists of two things: . | A fuzz test configuration file (&lt;fuzz_test&gt;.yaml). | HTTP requests necessary to authenticate to the application. | . The fuzz test configuration file contains several options that can be configured to adjust the behavior of your fuzz test. Some options are specific to the type of fuzz test you are performing (HTTP vs gRPC). Note: the directory containing the fuzz tests can be configured in .code-intelligence/project.yaml if needed by setting the web_app_target_configs option.code-intelligence/fuzz_test_seed_corpus . The &lt;fuzz_test&gt;_seed_corpus directory should contain manual seeds that you add to improve the fuzz test. ",
    "url": "http://localhost:4000/web-api-fuzzing#template-overview",
    "relUrl": "/web-api-fuzzing#template-overview"
  },"78": {
    "doc": "Web API Fuzzing",
    "title": "Configure the Template",
    "content": "Configure the template files as follows depending on if you are fuzzing HTTP or gRPC. HTTP / REST .code-intelligence/web_services.yaml . Change the name of the web_service if desired. A web service can have any name as long as it matches that used by the fuzzing agent and listed in .code-intelligence/project.yaml. If your application has an OpenAPI / swagger specification file, add the path to it in this file on the line containing open_api_spec. The path is relative to the root directory of the git repository. CI Fuzz will parse this file and automatically generate seeds to use for fuzzing. An OpenAPI specification corresponds to a specific web service.code-intelligence/fuzz_targets/fuzz_test.yaml . Configure the following in your &lt;fuzz_test&gt;.yaml file: . | Set protocol to http. | Set base_url to the address where the application you are testing will be running. Include the protocol when specifying the address: http(s):// | Enable and set allowed_requests to whichever HTTP paths (endpoints) the fuzzer should test. This is optional. | Enable and set denied_requests to whicheer HTTP paths (endpoints) the fuzzer should not attempt to test. This is optional. | Enable and set health_check_url to an endpoint that CI Fuzz can use to verify the target application is reachable and running. This is optional. | .code-intelligence/project.yaml . Set the web_app_target_configs to the path to the &lt;fuzz_test&gt;.yaml files in .code-intelligence/fuzz_targets/. gRPC .code-intelligence/web_services.yaml . Change the name of the web_service if desired. A web service can have any name as long as it matches that used by the fuzzing agent and listed in .code-intelligence/project.yaml.code-intelligence/fuzz_targets/fuzz_test.yaml . Configure the following in your &lt;fuzz_test&gt;.yaml file: . | Set protocol to grpc. | Set base_url to the address where the application you are testing will be running. Specify the address as [DOMAIN | IP]:[PORT]. | Enable and set run_extra_args to be \"--proto_stub_path=./libproto_stub.so\". | Enable and set health_check_url to an endpoint that CI Fuzz can use to verify the target application is reachable and running. This is optional. | .code-intelligence/project.yaml . Set the web_app_target_configs to the path to the &lt;fuzz_test&gt;.yaml files in .code-intelligence/fuzz_targets/. ",
    "url": "http://localhost:4000/web-api-fuzzing#configure-the-template",
    "relUrl": "/web-api-fuzzing#configure-the-template"
  },"79": {
    "doc": "CI Fuzz",
    "title": "CI Fuzz",
    "content": " ",
    "url": "http://localhost:4000/ci-fuzz",
    "relUrl": "/ci-fuzz"
  },"80": {
    "doc": "CI Fuzz",
    "title": "CI Fuzz Architecture",
    "content": ". ",
    "url": "http://localhost:4000/ci-fuzz#ci-fuzz-architecture",
    "relUrl": "/ci-fuzz#ci-fuzz-architecture"
  },"81": {
    "doc": "CI Fuzz",
    "title": "Included Components",
    "content": "A CI Fuzz installation consists of several components. Backend API server . The main backend server offers a gRPC API which allows clients to set up fuzzing projects, start / monitor / stop fuzzers, inspect findings and much more. Additionally, the gRPC API is automatically converted to a REST API using a grpc gateway which allows for easier integration of the API in a JavaScript environment. Database . A Postgres database is used to persist fuzzing results and user data. The database configured in the included docker-compose setup works out of the box, however, it is also possible to connect to an already configured Postgres database. Gateway . The gateway service serves as a reverse proxy for all other components and is the single entry point for the CI Fuzz backend. It also hosts the Web App, does TLS termination and handles the OAuth flow. Reporting . The reporting service uses the API to generate reports in pdf, docx and xlsx format. Worker . The worker runs and monitors jobs are created by the API server. The most common job is the execution of a fuzzer and the evaluation of line coverage. All jobs are currently run inside Docker containers which are spawned alongside the docker-compose setup (Docker out of Docker). The API Server is configured to start 4 worker instances by default. Web App . A single page web app which can be accessed to configure fuzzing projects, monitor fuzzer execution and get detailed information on findings that were detected by fuzzers. This is hosted by the Gateway container. Command Line Client . The installation also includes a command line client named cictl. It communicates with the API server via gRPC and can be used to start fuzzing jobs from CI/CD pipelines and other common tasks involving the CI Fuzz backend API. ",
    "url": "http://localhost:4000/ci-fuzz#included-components",
    "relUrl": "/ci-fuzz#included-components"
  },"82": {
    "doc": "CI Fuzz CLI",
    "title": "CI Fuzz CLI",
    "content": "The CI Fuzz CLI is an open source command line tool for creating fuzz tests. CI Fuzz CLI is tightly integrated with various build systems, enabling developers to create fuzz tests as easily as unit tests. You can find the CI Fuzz CLI GitHub repository here. ",
    "url": "http://localhost:4000/cifuzz-cli",
    "relUrl": "/cifuzz-cli"
  },"83": {
    "doc": "CI Fuzz CLI",
    "title": "Features",
    "content": ". | Easily setup, create, and run fuzz tests | Generate coverage reports that can be integrated in your IDE | Supports multiple programming languages and build systems | . ",
    "url": "http://localhost:4000/cifuzz-cli#features",
    "relUrl": "/cifuzz-cli#features"
  },"84": {
    "doc": "CI Fuzz CLI",
    "title": "Languages and Build Systems",
    "content": "CI Fuzz CLI supports the following language and build system combinations: . | C/C++ - CMake, Bazel, Other* | Java - Maven, Gradle | . * CI Fuzz CLI provides general support for other build systems such as Make, Ninja, and Meson. ",
    "url": "http://localhost:4000/cifuzz-cli#languages-and-build-systems",
    "relUrl": "/cifuzz-cli#languages-and-build-systems"
  },"85": {
    "doc": "CI Fuzz CLI",
    "title": "Getting Started",
    "content": "If you are new to CI Fuzz CLI, or just fuzz testing in general, then check out our quick start guides. They will walk you through creating your first fuzz test with CI Fuzz CLI. Quick Start C/C++ Quick Start Java . ",
    "url": "http://localhost:4000/cifuzz-cli#getting-started",
    "relUrl": "/cifuzz-cli#getting-started"
  },"86": {
    "doc": "Installation",
    "title": "Installing CI Fuzz",
    "content": "This page will walk you through installing CI Fuzz. Before you begin, you should have received: . | the CI Fuzz on-prem installer (ci-fuzz-on-prem-installer-&lt;version&gt;-linux) | a docker image bundle (ci-fuzz-on-prem-images-&lt;version&gt;-linux) | . ",
    "url": "http://localhost:4000/ci-fuzz-installation#installing-ci-fuzz",
    "relUrl": "/ci-fuzz-installation#installing-ci-fuzz"
  },"87": {
    "doc": "Installation",
    "title": "Table of contents",
    "content": ". | Prerequisites | Step 1: Get a TLS certificate | Step 2: Run the installer | Step 3: Configuration | Step 4: Run server | . ",
    "url": "http://localhost:4000/ci-fuzz-installation#table-of-contents",
    "relUrl": "/ci-fuzz-installation#table-of-contents"
  },"88": {
    "doc": "Installation",
    "title": "Prerequisites",
    "content": "In order to use the provided install mechanism and the resulting docker-compose setup, some prerequisites have to be met. We recommend using a server with at least: . | 32 GB RAM | 16 or more CPU cores | 100 GB storage | A Linux operating system | ssh access (or equivalent) | Docker and Docker-Compose | root privileges (if you want to use port 80/443) | Open ports. See Ports and Network Settings for details | Access to a docker registry. | . Linux . The only supported operating system is Linux. Most linux distributions will be fine, while the most comfort can be achieved by using one that supports systemd. If in doubt, we recommend using Ubuntu Server. TLS . Operating system’s certificate store must be in the following location: . /etc/ssl/certs/ca-certificates.crt . This is the default on Ubuntu and Debian. On Centos, you need to create a hard link here: . ln /etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt /etc/ssl/certs/ca-certificates.crt . Docker . Docker-Compose relies on docker being installed on the host system. To do so, follow the provided instructions for your distribution as depicted in the docker engine documentation. Additionally, CI Fuzz runs fuzz tests inside specific Docker containers. These docker containers are specified as part of the fuzz tests themselves, but the CI Fuzz server must have access to these docker images. They can either be pulled from a docker registry (internal or external) or otherwise placed on the CI Fuzz server. Docker-Compose . In addition to the docker engine, the setup uses docker-compose to orchestrate its components. To setup docker-compose, follow the installation instructions. The minimum supported docker-compose version is 1.27.0. CI Fuzz also supports the Compose plugin for Docker (docker compose). Systemd . Having docker-compose allows to easily start and stop the service. But to be (re)started at boot, additional work has to be done. The installer provides a shortcut by setting up a systemd system service. Ports and Network Settings . This table provides some details about potential port requirements that may be needed. Note AUT is the Application Under Test and applies to Web API fuzzing only. | Port | Protocol | Source | Destination | Purpose | Comments | . | 443 | TCP | Browser | CI Server | Access CI Fuzz web application to view and manage findings | Port is configurable in CI Fuzz | . | OAuth Provider Port | TCP | CI Server | OAuth Provider | CI Server contacts the OAuth provider during authentication. |   | . | 443 | TCP | cictl | CI Server | Start fuzz tests, upload artifacts, monitor status | Port is configurable in CI Fuzz | . | 443 | TCP | CI/CD Server | CI Server | CI/CD server can initiate jobs on CI Server | Port is configurable in CI Fuzz | . | 6777-7777 | TCP | AUT | CI Server | Java agent to contact CI Server with finding and coverage information | Web API fuzzing only. Port range is configurable in CI Fuzz | . | AUT Listening Port | TCP | CI Server | AUT | Send fuzzing inputs to AUT | Port depends on listening port of AUT. Web API fuzzing only. | . A DNS entry for your CI Fuzz server must exist, or you need a custom TLS certificate that is valid for an IP address. ",
    "url": "http://localhost:4000/ci-fuzz-installation#prerequisites",
    "relUrl": "/ci-fuzz-installation#prerequisites"
  },"89": {
    "doc": "Installation",
    "title": "Step 1: Get a TLS certificate",
    "content": "For secure TLS connections to the fuzzing server, a TLS certificate is needed. Your company may already use a specific CA or run its own. If not, you can get free TLS certificates from Let’s Encrypt. Just install the command line tool certbot and request a certificate with a single command: . sudo apt install certbot sudo certbot certonly --standalone --preferred-challenges http -d &lt;your domain&gt; . ",
    "url": "http://localhost:4000/ci-fuzz-installation#step-1-get-a-tls-certificate",
    "relUrl": "/ci-fuzz-installation#step-1-get-a-tls-certificate"
  },"90": {
    "doc": "Installation",
    "title": "Step 2: Run the installer",
    "content": "You should have received a link for the installer and a docker image bundle (CI Fuzz on-premise backend image bundle) from Code Intelligence. Run the installer with the docker image bundle as shown here: . chmod +x ci-fuzz-on-prem-installer-&lt;version&gt;-linux ./ci-fuzz-on-prem-installer-&lt;version&gt;-linux --docker-images &lt;path to your bundle&gt; . You need at least 10 GB of free disk space to run the installer when using the image bundle, as it needs to create some temporary files.  . ",
    "url": "http://localhost:4000/ci-fuzz-installation#step-2-run-the-installer",
    "relUrl": "/ci-fuzz-installation#step-2-run-the-installer"
  },"91": {
    "doc": "Installation",
    "title": "Step 3: Configuration",
    "content": "When CI Fuzz is started it will load all configuration variables found in /opt/ci-fuzz-&lt;version&gt;/cifuzz.env. It will then search for any .env files in /etc/cifuzz. Any variables defined there will overwrite those originally taken from /opt/ci-fuzz-&lt;version&gt;/cifuzz.env. Data Storage Locations . The following table lists the standard locations and components for persisted data for a CI Fuzz installation. This is a useful reference when planning your initial installation and how you will handle upgrades and backups. | Data Item | Default Location | Purpose | Configurable | Comments | . | CIFUZZ_DATA_DIR | $HOME/.local/share/cifuzz | Directory containing fuzzing artifacts and corpora | Location can be configured in .env files in /etc/cifuzz | The directory can be a network share. | . | CI Fuzz Database | /var/lib/docker/volumes/cifuzz_db-data/_data | Postgres database for storing fuzzing results and user data. | Not configurable in CI Fuzz | Backup/tar this directory. See note below | . | Configuration files | /etc/cifuzz | cictl | Configuration files for CI Fuzz | CI Fuzz first looks for cifuzz.env and then applies any additional .env files that are found in the directory specified by cifuzz-server –env-files-from | . Note: If deploying CI Fuzz to a new system / image, it is recommended you first start CI Fuzz to initialize the docker volume directory. Then stop CI Fuzz, copy over the database backup, and restart CI Fuzz. 3.1 First Time Install . If this is your first time installing CI Fuzz, you will need to create the /etc/cifuzz directory. sudo mkdir /etc/cifuzz/ . You can download this template to /etc/cifuzz/cifuzz.env and then fill in the values as described below. You can use the command: . sudo wget https://docs.code-intelligence.com/assets/files/cifuzz.env.template -O /etc/cifuzz/cifuzz.env . | CIFUZZ_SERVER_ORIGIN - change to the hostname of the host where you are running CI Fuzz server. Please set full origin here - protocol (https), hostname and port. If you are using OAuth, then this must match the origin set in your OAuth application. | CIFUZZ_SERVER_PORT you can change the port if needed. Defaults to 8080 if not set. | CIFUZZ_CERT_FILE and CIFUZZ_CERT_KEY - absolute paths to the certificate and key that CI Fuzz should use. | CIFUZZ_INTER_SERVICE_AUTH_KEY - generate a random key using openssl rand -hex 32 or equivalent. | CIFUZZ_NUM_WORKER_THREADS - set to the number of CPU cores available | CI Fuzz Authentication - there are several ways to configure authentication to the CI Fuzz Web Application. The template contains areas for various OAuth applications. You only need to fill in the values for one of them. See Authentication for details on different authentication options. | . 3.2 Upgrading CI Fuzz . If you are upgrading CI Fuzz from a previous version, there is no need to adjust your configuration options in /etc/cifuzz/cifuzz.env unless new functionality has been added that you would like to use. To upgrade CI Fuzz, first stop the service with, then install CI Fuzz with the new docker images, and then restart the service: . sudo systemctl stop cifuzz chmod +x ci-fuzz-on-prem-installer-&lt;version&gt;-linux ./ci-fuzz-on-prem-installer-&lt;version&gt;-linux --docker-images &lt;path to your bundle&gt; sudo systemctl start cifuzz . ",
    "url": "http://localhost:4000/ci-fuzz-installation#step-3-configuration",
    "relUrl": "/ci-fuzz-installation#step-3-configuration"
  },"92": {
    "doc": "Installation",
    "title": "Step 4: Run server",
    "content": "sudo systemctl start cifuzz sudo systemctl enable cifuzz #to make it autostart after reboot . Check if CI Fuzz containers have been started successfully: . sudo docker ps . The output should look similar to this: . CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2833328092d9 f5d6e55758e0d08d.azurecr.io/cifuzz/ci-worker:2.42.0 \"/usr/bin/java -cp /…\" 11 seconds ago Up 7 seconds 0.0.0.0:6778-&gt;6777/tcp, :::6778-&gt;6777/tcp cifuzz-ci-worker-1 dba452af7e81 f5d6e55758e0d08d.azurecr.io/cifuzz/ci-backend:2.42.0 \"/usr/bin/java -cp /…\" 11 seconds ago Up 7 seconds 0.0.0.0:6777-&gt;6777/tcp, :::6777-&gt;6777/tcp cifuzz-ci-backend-1 bc3e5af64601 prometheuscommunity/postgres-exporter:v0.10.0 \"/bin/postgres_expor…\" 11 seconds ago Up 7 seconds 0.0.0.0:9187-&gt;9187/tcp, :::9187-&gt;9187/tcp cifuzz-db-metrics-1 909f0f946f26 f5d6e55758e0d08d.azurecr.io/cifuzz/reporting:2.42.0 \"/usr/bin/java -cp /…\" 11 seconds ago Up 8 seconds cifuzz-reporting-1 86d83d710634 postgres:12.7 \"docker-entrypoint.s…\" 11 seconds ago Up 8 seconds 5432/tcp cifuzz-db-1 6975de4d7388 f5d6e55758e0d08d.azurecr.io/cifuzz/gateway:2.42.0 \"/app/cmd/gateway/ba…\" 11 seconds ago Up 8 seconds 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp cifuzz-gateway-1 . ",
    "url": "http://localhost:4000/ci-fuzz-installation#step-4-run-server",
    "relUrl": "/ci-fuzz-installation#step-4-run-server"
  },"93": {
    "doc": "Installation",
    "title": "Installation",
    "content": " ",
    "url": "http://localhost:4000/ci-fuzz-installation",
    "relUrl": "/ci-fuzz-installation"
  },"94": {
    "doc": "Java Web API Fuzzing",
    "title": "Java Web API Fuzzing",
    "content": "CI Fuzz is capable of coverage-guided fuzzing for Java-based REST and GRPC APIs. This section will guide you through the initial setup of a Java Web API fuzzing project. ",
    "url": "http://localhost:4000/java-web-api-fuzzing",
    "relUrl": "/java-web-api-fuzzing"
  },"95": {
    "doc": "Java Web API Fuzzing",
    "title": "Table of contents",
    "content": ". | Prerequisites | Web API Server | Configure Java Agent . | Java Agent Parameters | . | Example CI/CD Script | . ",
    "url": "http://localhost:4000/java-web-api-fuzzing#table-of-contents",
    "relUrl": "/java-web-api-fuzzing#table-of-contents"
  },"96": {
    "doc": "Java Web API Fuzzing",
    "title": "Prerequisites",
    "content": "Before you proceed with this guide, you should have already: . | Installed CI Fuzz and the build tools. | Configured authentication. | Created a project. | Configured your Web API using the template. | . ",
    "url": "http://localhost:4000/java-web-api-fuzzing#prerequisites",
    "relUrl": "/java-web-api-fuzzing#prerequisites"
  },"97": {
    "doc": "Java Web API Fuzzing",
    "title": "Web API Server",
    "content": "Your Web API can run anywhere as long as it is reachable from the server hosting CI Fuzz. Port details are provided below. Typically, this would be one of the following: . | On the CI/CD server (gitlab/github/jenkins server) | On the CI Fuzz server | A separate server (e.g. your integration testing cluster) | . If you choose to run your Web API on a separate server from the one hosting CI Fuzz, you need to make sure that: . | The Web API is exposed on a network interface and the port on which it is running is reachable from CI Fuzz. | Ports 443 or 80 and 6777-7777 on the server running CI Fuzz are reachable from the server hosting your Web API. | . ",
    "url": "http://localhost:4000/java-web-api-fuzzing#web-api-server",
    "relUrl": "/java-web-api-fuzzing#web-api-server"
  },"98": {
    "doc": "Java Web API Fuzzing",
    "title": "Configure Java Agent",
    "content": "The javaagent is responsible for instrumenting the Web API to collect coverage information. This coverage information is sent back to CI Fuzz to help it determine which code paths to follow and how to mutate the inputs to your Web API. The CI Fuzz Agent is deployed with your Web API. CI Fuzz will provide the command line argument that is needed to deploy the agent alongside your target application: . | Open CI Fuzz in your browser | From the left sidebar, select your project from the dropdown menu. | Click Project Settings | Click WEB SEVICES | Click the ADD WEB SERVICE button. | Add a name in the Web Service Identifier textbox. The name/identifier can be whatever you like, but it must match the name in the .code-intelligence/web_services.yaml file. If you used the template project, the name is mywebservice by default. | If the target application is not running on the same server as CI Fuzz, click Use Custom Fuzzing Server Settings to specify the host and port where the CI Fuzz Agent can reach CI Fuzz. The host | Click NEXT. | Select JAVA | Copy the appropriate command line argument (depending on if your application uses JAVA_OPTS or not). | . Here is an example javaagent argument string: . -javaagent:path/to/downloaded/fuzzing_agent.jar=service_name=projects/webgoat-27096bd3/web_services/mywebservice,fuzzing_server_host=grpc.code-intelligence.com,fuzzing_server_port=443,api_token=$CI_FUZZ_API_TOKEN,cert_file=$CERT_FILE,tls=true . Java Agent Parameters . The javaagent supports the following parameters: . | path/to/downloaded/fuzzing_agent.jar - set the path of the javaagent. The javaagent must be available to the Web API The recommended way to acquire the javaagent (fuzzing_agent.jar) is to use the command cictl get javaagent to download it. There is an example of this below. | service_name - a name which should be unique to be distinguishable from other services e.g. service_name=projects/example-9070daab/web_services/example. This is typically generated for you by CI Fuzz during web service creation. | api_token - the javaagent needs the CI Fuzz API token to authenticate to CI Fuzz. | instrumentation_includes - a : separated list of package glob patterns to include in the instrumentation e.g. instrumentation_includes=com.google.**:com.example.**. Only the feedback that is received for the specified package patterns will affect the fuzzing input generation and path discovery of the code. Though not technically required, failure to specify will result in the javaagent instrumenting all packages (including native Java packages). This typically results in the JVM running out of memory as well as the fuzzer spending time exploring packages that you may not be interested in. | instrumentation_excludes - a : separated list of package glob patterns to exclude from the instrumentation. | tls - set to true if CI Fuzz has TLS enabled, otherwise set to false. When true, this will encrypt the communication between CI Fuzz and the javaagent. The gRPC communication between the fuzzer and javaagent is still unencrypted. | cert_file - The location of the certificate of the CA that signed the TLS certificate of the CI Fuzz server. Only required if the cert is not signed by a public CA. | fuzzing_server_host - use a host name that is listed in the server’s TLS certificate, otherwise the TLS connection will fail. | fuzzing_server_port - port where CI Fuzz can be reached. | . ",
    "url": "http://localhost:4000/java-web-api-fuzzing#configure-java-agent",
    "relUrl": "/java-web-api-fuzzing#configure-java-agent"
  },"99": {
    "doc": "Java Web API Fuzzing",
    "title": "Example CI/CD Script",
    "content": "This is an example Gitlab CI job that will start a Java Web API with javaagent on another server. In this example, the deployment server already has the cictl tool and uses it to download the javaagent. You can also download the java agent in the CI/CD pipeline and then copy it to the deployment server. deploy: stage: deploy image: cifuzz/ubuntu-ssh before_script: - eval $(ssh-agent -s) - echo \"\"$SSH_PRIVATE_KEY\"\" | tr -d '\\\\r' | ssh-add - - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"\"$SSH_KNOWN_HOSTS\"\" &gt;&gt; ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts variables: DEPLOY_HOST: azureuser@on-prem-l000003 script: - echo \"\"Kill currently running app...\"\" - ssh $DEPLOY_HOST pkill -f rest-service || true - echo \"\"Copy app binary...\"\" - ls build/libs - scp build/libs/rest-service-?.?.?.jar $DEPLOY_HOST:~ - echo \"\"Prepare CA certificate for connecting to CI Fuzz...\"\" - cat $CA_CERT - scp $CA_CERT $DEPLOY_HOST:~/CA.pem - echo \"\"download correct version of java agent from CI Fuzz server\"\" - ssh $DEPLOY_HOST \"\"echo $CI_FUZZ_API_TOKEN | ./cictl login -s $FUZZING_SERVER\"\" - ssh $DEPLOY_HOST \"\"./cictl get javaagent -s $FUZZING_SERVER\"\" - echo \"\"Run app...\"\" - FUZZING_SERVER_HOST=$(echo $FUZZING_SERVER|cut -d ':' -f 1) - FUZZING_SERVER_PORT=$(echo $FUZZING_SERVER|cut -d ':' -f 2) - echo \"java -javaagent:fuzzing_agent.jar=fuzzing_server_host=$FUZZING_SERVER_HOST,fuzzing_server_port=$FUZZING_SERVER_PORT,service_name=$PROJECT/web_services/mywebservice,api_token=$CI_FUZZ_API_TOKEN,cert_file=CA.pem,instrumentation_includes=\\\\\"\"com.cifuzzexample.\\*\\*\\\\\"\" -Dserver.port=$SUT_PORT -jar rest-service-\\*.jar &gt; output.log 2&gt;&amp;1 &amp;\" &gt; javacommand - scp javacommand $DEPLOY_HOST:~ - ssh $DEPLOY_HOST \"\"chmod u+x javacommand &amp;&amp; ./javacommand\"\" . ",
    "url": "http://localhost:4000/java-web-api-fuzzing#example-cicd-script",
    "relUrl": "/java-web-api-fuzzing#example-cicd-script"
  },"100": {
    "doc": "Project Creation",
    "title": "Project Creation",
    "content": "This section will guide you through creating a new project in the UI of CI Fuzz. ",
    "url": "http://localhost:4000/ci-fuzz-project-creation",
    "relUrl": "/ci-fuzz-project-creation"
  },"101": {
    "doc": "Project Creation",
    "title": "Table of contents",
    "content": ". | Prerequisites | Add New Project | . ",
    "url": "http://localhost:4000/ci-fuzz-project-creation#table-of-contents",
    "relUrl": "/ci-fuzz-project-creation#table-of-contents"
  },"102": {
    "doc": "Project Creation",
    "title": "Prerequisites",
    "content": "Before creating a project, you should have already: . | Installed CI Fuzz. | Configured authentication. | . ",
    "url": "http://localhost:4000/ci-fuzz-project-creation#prerequisites",
    "relUrl": "/ci-fuzz-project-creation#prerequisites"
  },"103": {
    "doc": "Project Creation",
    "title": "Add New Project",
    "content": "Start by logging into CI Fuzz. From the Dashboard, you can either: . | Click the Select Project dropdown and then Add Project | Click the NEW PROJECT button | . This will spawn a dialog box to enter information about the project: . | Projects can be customized with a logo of your choosing. If you do not select a logo, then CI Fuzz will generate one for you. | If a project is marked as Personal, it will not belong to an organization. | Enter a name for the project. | If a project is not marked as Personal, then it must belong to an organization. | If your project currently resides in a Git repository, you can add the URL. This is optional, but recommended if possible. | You can add a description of your project. | . ",
    "url": "http://localhost:4000/ci-fuzz-project-creation#add-new-project",
    "relUrl": "/ci-fuzz-project-creation#add-new-project"
  },"104": {
    "doc": "Quick Start C/C++",
    "title": "Quick Start C/C++",
    "content": "This quick start guide is intended to teach you the basics of using cifuzz with a C/C++ project. cifuzz directly supports CMake and Bazel, but can also be configured to work with other build systems such as Make. This guide was created using Ubuntu 20.04 x64. If you are on MacOS or Windows, you should be able to follow along without any issues. If you have not yet installed cifuzz, then first head to the installation section . ",
    "url": "http://localhost:4000/cli-quick-start-cpp",
    "relUrl": "/cli-quick-start-cpp"
  },"105": {
    "doc": "Quick Start C/C++",
    "title": "Table of contents",
    "content": ". | CMake . | 1. Setting Up | 2. Initialize the Project | 3. Creating a Fuzz Test | 4. Running the Fuzz Test | 5. Examine Findings | . | Bazel . | 1. Setting Up | 2. Initialize the Project | 3. Creating a Fuzz Test | 4. Running the Fuzz Test | 5. Examine Findings | . | . ",
    "url": "http://localhost:4000/cli-quick-start-cpp#table-of-contents",
    "relUrl": "/cli-quick-start-cpp#table-of-contents"
  },"106": {
    "doc": "Quick Start C/C++",
    "title": "CMake",
    "content": "1. Setting Up . Download or clone the following repository: https://github.com/CodeIntelligenceTesting/ci-fuzz-cli-getting-started. This repository contains several projects. For this guide, you will use the project in the tutorials/c_cpp/cmake directory. Note: all cifuzz commands listed in this section should be run from the c_cpp/cmake directory. 2. Initialize the Project . The first step for any project is to initialize it. Initialization means creating a configuration file, cifuzz.yaml, in the project directory and modifying your top level CMakeLists.txt file. Run the following command: . cifuzz init . When you run cifuzz init it will recognize the project as a CMake project and provide two commands that you have to add to CMakeLists.txt: . | find_package(cifuzz NO_SYSTEM_ENVIRONMENT_PATH) - finds and loads the cifuzz package for use when building the project. | enable_fuzz_testing() - enables integration between cifuzz and CMake | . Note: These commands must be added before any add_library or add_executable directives, otherwise the targets will not be compiled with the correct instrumentation/build flags. Add the two CMake commands to CMakeLists.txt. After editing CMakeLists.txt, it should look something like this: . cmake_minimum_required(VERSION 3.16) project(cmake_example) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) enable_testing() find_package(cifuzz NO_SYSTEM_ENVIRONMENT_PATH) enable_fuzz_testing() add_subdirectory(src) add_executable(${PROJECT_NAME} main.cpp ) target_link_libraries(${PROJECT_NAME} PRIVATE exploreMe) . 3. Creating a Fuzz Test . The next step is to create a c++ fuzz test template. With one of the main goals of cifuzz being to make fuzz testing as easy as unit testing, we’ll place the fuzz test in the test directory, just as we would a standard unit test. Run the following command: . cifuzz create cpp -o test/my_fuzz_test.cpp . If you open test/my_fuzz_test.cpp, you should see a fuzz test template. After creating your fuzz test, you need to add the add_fuzz_test and target_link_libraries commands to your CMakeLists.txt file so CMake can find, build, and link your fuzz test. After adding these two commands, your CMakeLists.txt should look like: . cmake_minimum_required(VERSION 3.16) project(cmake_example) set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) enable_testing() find_package(cifuzz NO_SYSTEM_ENVIRONMENT_PATH) enable_fuzz_testing() add_subdirectory(src) add_executable(${PROJECT_NAME} main.cpp ) target_link_libraries(${PROJECT_NAME} PRIVATE exploreMe) add_fuzz_test(my_fuzz_test test/my_fuzz_test.cpp) target_link_libraries(my_fuzz_test PRIVATE exploreMe) . Before we write the fuzz test, take a look at the target function that we want to fuzz. It is located in src/explore_me.cpp: . void exploreMe(int a, int b, string c) { if (a &gt;= 20000) { if (b &gt;= 2000000) { if (b - a &lt; 100000) { if (c == \"FUZZING\") { // Trigger a heap buffer overflow char *s = (char *)malloc(1); strcpy(s, \"too long\"); printf(\"%s\\n\", s); } } } } } . The main parts to focus on here is the parameters that the exploreMe function requires, int a, int b, string c. As long as we can pass the correct data types to the function, the fuzzer will take care of the rest. Now we’ll write the fuzz test. You can write or copy/paste the following into test/my_fuzz_test.cpp: . #include \"../src/explore_me.h\" #include &lt;cifuzz/cifuzz.h&gt; #include &lt;fuzzer/FuzzedDataProvider.h&gt; FUZZ_TEST_SETUP() {} FUZZ_TEST(const uint8_t *data, size_t size) { FuzzedDataProvider fuzzed_data(data, size); int a = fuzzed_data.ConsumeIntegral&lt;int&gt;(); int b = fuzzed_data.ConsumeIntegral&lt;int&gt;(); std::string c = fuzzed_data.ConsumeRandomLengthString(); exploreMe(a, b, c); } . A few notes about this fuzz test: . | The fuzz test must include the header for the target function (../src/explore_me.h) and cifuzz (&lt;cifuzz/cifuzz.h&gt;) | This fuzz test uses the FuzzedDataProvider from LLVM. This is not required, but it is a convenient way to split the fuzzing input in the data variable into different data types. Here is a link to the FuzzedDataProvider header file if you want to view it’s other methods. | Once we have created the appropriate variables (a, b, and c) using data from the fuzzer, the fuzz test just has to call the target function (exploreMe) with the fuzz data. | . 4. Running the Fuzz Test . Everything is configured and the fuzz test is created. Run the fuzz test using: . cifuzz run my_fuzz_test . After a moment you should be notified that cifuzz discovered a heap buffer overflow. Here is a snippet of the output: . &lt;snip&gt; 💥 [nifty_lemming] heap buffer overflow in exploreMe (src/explore_me.cpp:14:11) &lt;snip&gt; . 5. Examine Findings . When cifuzz discovers a finding, it stores the output from the finding and the input that caused it. You can list all findings discovered so far by running cifuzz findings. If you want to see the details of a specific finding just provide it’s name, e.g. cifuzz finding nifty_lemming. This will provide the stack trace and other details about the finding that will help you debug and fix the issue. Examining the output from cifuzz finding nifty_lemming below shows that there was a WRITE of size 9 and this was triggered at line 14 in the exploreMe function. &lt;snip&gt; ==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000d95838 at pc 0x000000523dea bp 0x7fff5cf6f100 sp 0x7fff5cf6e8c8 WRITE of size 9 at 0x602000d95838 thread T0 #0 0x523de9 in __asan_memcpy (/home/demo/repos/quick-start/c_cpp/cmake/.cifuzz-build/libfuzzer/address+undefined/my_fuzz_test+0x523de9) #1 0x559763 in exploreMe(int, int, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /home/demo/repos/quick-start/c_cpp/cmake/src/explore_me.cpp:14:11 &lt;snip&gt; . If you examine lines 13 and 14 in src/explore_me.cpp, you can see this is where a strcpy call attempts to copy too many bytes to the buffer. cifuzz also stores the crashing input in a directory named _inputs. That would be `my_fuzz_test_inputs` in this example. The crashing input has the same name as the finding. Findings in this directory will be used as inputs for future runs to help identify regressions. See the [regression testing](/docs/ci-fuzz-cli/cli-regression-testing.md) section for additional information on creating regression tests from your fuzzing inputs. ",
    "url": "http://localhost:4000/cli-quick-start-cpp#cmake",
    "relUrl": "/cli-quick-start-cpp#cmake"
  },"107": {
    "doc": "Quick Start C/C++",
    "title": "Bazel",
    "content": "1. Setting Up . Download or clone the following repository: https://github.com/CodeIntelligenceTesting/ci-fuzz-cli-getting-started. This repository contains several projects. For this guide, you will use the project in the tutorials/c_cpp/bazel directory. Note: all cifuzz commands listed in this section should be run from the c_cpp/bazel directory. 2. Initialize the Project . The first step for any project is to initialize it. Initialization means creating a configuration file, cifuzz.yaml, in the project directory and modifying your top level WORKSPACE file. Run the following command: . cifuzz init . When you run cifuzz init it will recognize the project as a Bazel project and provide the rules you need to add your WORKSPACE file. Add the following to WORKSPACE: . load(\"@bazel_tools//tools/build_defs/repo:git.bzl\", \"git_repository\") load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\") http_archive( name = \"rules_fuzzing\", sha256 = \"93353c864968596cfee046ea1ef587ff62eda90dd24d4360c70465376e507982\", strip_prefix = \"rules_fuzzing-2492fd2f37163de8e19ce85061e90a464f3e9255\", urls = [\"https://github.com/bazelbuild/rules_fuzzing/archive/2492fd2f37163de8e19ce85061e90a464f3e9255.tar.gz\"], ) load(\"@rules_fuzzing//fuzzing:repositories.bzl\", \"rules_fuzzing_dependencies\") rules_fuzzing_dependencies() load(\"@rules_fuzzing//fuzzing:init.bzl\", \"rules_fuzzing_init\") rules_fuzzing_init() git_repository( name = \"cifuzz\", branch = \"bazel-support\", remote = \"https://github.com/CodeIntelligenceTesting/cifuzz\", strip_prefix = \"tools/cmake/cifuzz/include/cifuzz\", ) . These rules will enable cifuzz to integrate directly with your Bazel project. 3. Creating a Fuzz Test . The next step is to create a c++ fuzz test template. With one of the main goals of cifuzz being to make fuzz testing as easy as unit testing, we’ll place the fuzz test in the test directory, just as we would a standard unit test. Run the following command: . cifuzz create cpp -o test/my_fuzz_test.cpp . If you open test/my_fuzz_test.cpp, you should see a fuzz test template. After creating your fuzz test template, you need to define a bazel target by adding the following to the file test/BUILD.bazel: . load(\"@rules_fuzzing//fuzzing:cc_defs.bzl\", \"cc_fuzz_test\") cc_fuzz_test( name = \"my_fuzz_test\", srcs = [\"my_fuzz_test.cpp\"], corpus = glob( [\"my_fuzz_test_inputs/**\"], allow_empty = True, ), deps = [ \"//src:explore_me\", \"@cifuzz\" ], ) . Before we write the fuzz test, take a look at the target function that we want to fuzz. It is located in src/explore_me.cpp: . void exploreMe(int a, int b, string c) { if (a &gt;= 20000) { if (b &gt;= 2000000) { if (b - a &lt; 100000) { if (c == \"FUZZING\") { // Trigger a heap buffer overflow char *s = (char *)malloc(1); strcpy(s, \"too long\"); printf(\"%s\\n\", s); } } } } } . The main parts to focus on here is the parameters that the exploreMe function requires, int a, int b, string c. As long as we can pass the correct data types to the function, the fuzzer will take care of the rest. Now we’ll write the fuzz test. You can write or copy/paste the following into test/my_fuzz_test.cpp: . #include \"../src/explore_me.h\" #include &lt;cifuzz/cifuzz.h&gt; #include &lt;fuzzer/FuzzedDataProvider.h&gt; FUZZ_TEST_SETUP() {} FUZZ_TEST(const uint8_t *data, size_t size) { FuzzedDataProvider fuzzed_data(data, size); int a = fuzzed_data.ConsumeIntegral&lt;int&gt;(); int b = fuzzed_data.ConsumeIntegral&lt;int&gt;(); std::string c = fuzzed_data.ConsumeRandomLengthString(); exploreMe(a, b, c); } . A few notes about this fuzz test: . | The fuzz test must include the header for the target function (../src/explore_me.h) and cifuzz (&lt;cifuzz/cifuzz.h&gt;) | This fuzz test uses the FuzzedDataProvider from LLVM. This is not required, but it is a convenient way to split the fuzzing input in the data variable into different data types. Here is a link to the FuzzedDataProvider header file if you want to view it’s other methods. | Once we have created the appropriate variables (a, b, and c) using data from the fuzzer, the fuzz test just has to call the target function (exploreMe) with the fuzz data. | . 4. Running the Fuzz Test . Everything is configured and the fuzz test is created. Run the fuzz test using: . cifuzz run test:my_fuzz_test . After a moment you should be notified that cifuzz discovered a heap buffer overflow. Here is a snippet of the output: . &lt;snip&gt; 💥 [nifty_lemming] heap buffer overflow in exploreMe (src/explore_me.cpp:14:11) &lt;snip&gt; . 5. Examine Findings . When cifuzz discovers a finding, it stores the output from the finding and the input that caused it. You can list all findings discovered so far by running cifuzz findings. If you want to see the details of a specific finding just provide it’s name, e.g. cifuzz finding nifty_lemming. This will provide the stack trace and other details about the finding that will help you debug and fix the issue. Examining the output from cifuzz finding nifty_lemming below shows that there was a WRITE of size 9 and this was triggered at line 14 in the exploreMe function. &lt;snip&gt; ==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200010c631 at pc 0x55feceee57ba bp 0x7fffedca0920 sp 0x7fffedca00f0 WRITE of size 9 at 0x60200010c631 thread T0 #0 0x55feceee57b9 in __asan_memcpy (/home/demo/.cache/bazel/_bazel_demo/3aecbc2ad2c03b16fb4fba4e35b40215/execroot/__main__/bazel-out/k8-opt-ST-00475e028063/bin/test/my_fuzz_test_raw_+0x10e7b9) (BuildId: d6b308f8875b4621) #1 0x55fecef17e06 in exploreMe(int, int, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) src/explore_me.cpp:14:11 &lt;snip&gt; . If you examine lines 13 and 14 in src/explore_me.cpp, you can see this is where a strcpy call attempts to copy too many bytes to the buffer. cifuzz also stores the crashing input in a directory named _inputs. That would be `my_fuzz_test_inputs` in this example. The crashing input has the same name as the finding. Findings in this directory will be used as inputs for future runs to help identify regressions. See the [regression testing](/docs/ci-fuzz-cli/cli-regression-testing.md) section for additional information on creating regression tests from your fuzzing inputs. ",
    "url": "http://localhost:4000/cli-quick-start-cpp#bazel",
    "relUrl": "/cli-quick-start-cpp#bazel"
  },"108": {
    "doc": "Quick Start C/C++",
    "title": "Quick Start C/C++",
    "content": "This guide is intended to quickly get a local installation of CI Fuzz installed, configured, and running fuzz tests. ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp",
    "relUrl": "/ci-fuzz-quick-start-cpp"
  },"109": {
    "doc": "Quick Start C/C++",
    "title": "Table of contents",
    "content": ". | 1. Setting Up | 2. Run Installer with Docker Image Bundle | 3. Configure Password Login | 4. Project Setup | 5. Running the Fuzz Tests . | 5.1 Review Fuzz Test | 5.2 Finding Details | 5.3 Examine Coverage | . | . ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#table-of-contents",
    "relUrl": "/ci-fuzz-quick-start-cpp#table-of-contents"
  },"110": {
    "doc": "Quick Start C/C++",
    "title": "1. Setting Up",
    "content": "Before you start, you should have: . | The CI Fuzz installer and docker image bundle files from Code Intelligence. | Installed the CI Fuzz CLI | Root/sudo privileges on a systemd enabled Linux system (Ubuntu/Debian recommended). | Installed docker and docker compose on the system where CI Fuzz will be installed. | Network access to github from the CI Fuzz system (this is not required, but is helpful). | . ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#1-setting-up",
    "relUrl": "/ci-fuzz-quick-start-cpp#1-setting-up"
  },"111": {
    "doc": "Quick Start C/C++",
    "title": "2. Run Installer with Docker Image Bundle",
    "content": "Run the provided CI Fuzz installer with the docker image bundle. chmod +x ci-fuzz-on-prem-installer-&lt;version&gt;-linux ./ci-fuzz-on-prem-installer-&lt;version&gt;-linux --docker-images ci-fuzz-on-prem-images-&lt;version&gt;-linux . By default, this will create the directory /opt/ci-fuzz-&lt;version&gt;. This is the installation directory. We’ll start the service after we configure the server. ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#2-run-installer-with-docker-image-bundle",
    "relUrl": "/ci-fuzz-quick-start-cpp#2-run-installer-with-docker-image-bundle"
  },"112": {
    "doc": "Quick Start C/C++",
    "title": "3. Configure Password Login",
    "content": "There are multiple ways to configure authentication for CI Fuzz. For this installation, we will use the password authentication approach. If the directory /etc/cifuzz does not exist yet, create it and the file cifuzz.env now. mkdir /etc/cifuzz touch /etc/cifuzz/cifuzz.env . Open /etc/cifuzz/cifuzz.env with your preferred text editor and add the following values to it: . CIFUZZ_ENABLE_PASSWORD_LOGIN=1 DEMO_ORG_ADMIN_TOKEN=&lt;your_password_here&gt; . By default CI Fuzz runs on port 8080, but you can change this by adding the following line to /etc/cifuzz/cifuzz.env: . CIFUZZ_SERVER_PORT=&lt;port_number&gt; . This will enable us to login to the web application with just a password. This same password will be used as the access token by command line tools. Now start the CI Fuzz service: . sudo systemctl start cifuzz . ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#3-configure-password-login",
    "relUrl": "/ci-fuzz-quick-start-cpp#3-configure-password-login"
  },"113": {
    "doc": "Quick Start C/C++",
    "title": "4. Project Setup",
    "content": "Once CI Fuzz is running, you can access the web application at http://127.0.0.1:8080 in your browser. If you set a different port number in /etc/cifuzz/cifuzz.env be sure to use that port number instead. 4.1 Login to CI Fuzz . When you open the web application: . | You should see a button saying PASSWORD LOGIN. Click it. | Type the password you specified in /etc/cifuzz/cifuzz.env from Step 3 and click LOGIN. | This will take you to the dashboard. | . 4.2 Add New Project to CI Fuzz . Now you can add a project. You will need a repo to start fuzzing. Code Intelligence provides several demo projects which are a good way to start fuzzing and ensure everything is working correctly. We will use the c-cpp-demo project for this. To add the project to CI Fuzz, you should be at the dashboard in the web application: . | From the sidebar on the left where it says Select Project, click the dropdown and select Add Project. | Set the project as Personal. | Enter the name of the project: c-cpp-demo | Copy and paste the Git URL for the c-cpp-demo project (this one) in the text box and click ADD. If the system where you are installing CI Fuzz cannot reach github, you can skip this step. | . 4.3 Clone Repository Locally . This C/C++ demo already contains two fuzz tests and the necessary configuration information to work with CI Fuzz. Clone or download the project to the host where CI Fuzz is running. git clone https://github.com/CodeIntelligenceTesting/c-cpp-demo.git . ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#4-project-setup",
    "relUrl": "/ci-fuzz-quick-start-cpp#4-project-setup"
  },"114": {
    "doc": "Quick Start C/C++",
    "title": "5. Running the Fuzz Tests",
    "content": "You will use CI Fuzz CLI to run the fuzz tests from the command line. Run the following command from the root of the project directory where you cloned/copied the c-cpp-demo project: . CIFUZZ_API_TOKEN=&lt;your_password&gt; cifuzz remote-run -v --server \"http://127.0.0.1:8080\" --timeout=120s . Note: use the password you specified in /etc/cifuzz/cifuzz.env and be sure to adjust the IP and port if necessary. This command will bundle the c-cpp-demo project and submit it to the server. It will run each of the fuzz tests for 2 minutes (or until a crashing input is found). When you run the command above, it will ask you to select which project this fuzz test belongs to. Select the one you created earlier in section 4.2. Once the fuzz test is started, you can monitor the running fuzz tests in the UI: . | Open the browser and navigate to CI Fuzz. | Select your project from the dropdown in the top of the left sidebar. | Click one of the two fuzz tests (heap_buffer_overflow_test or stack_buffer_overflow_test) to view the metrics. | . | Coverage Metrics - this is the coverage level of CI Fuzz over time. In this case you can see the coverage increased from the beginning of the test and stayed relatively constant. This makes sense because this is a small demo application and CI Fuzz quickly discovered several interesting paths. | Performance Execution - the number of executions / second at a given time. This will vary based on your system resources, the fuzz test, and the code you are testing itself. | Unique Corpus Inputs - every time the fuzzer discovers an input that leads to a new code path (increases coverage), it adds it to a set of unique corpus inputs. These are stored and can be used again later as a way to check for regressions in your code as they will cover previously discovered code paths. | . 5.1 Review Fuzz Test . If you select Overview from the left sidebar, you will see the current overview of the project updated with results from the fuzz tests you just ran. This overview shows: . | that you have 2 total findings with 2 of them being new. | the job status of the recent fuzz test run. | the overall coverage for the project. | . 5.2 Finding Details . To get additional details about the findings, you can either click on the project overview pane, or select Findings from the left sidebar. From there you can select one of the findings to view. In this guide, we will focus on some key points about the finding, but if you want additional information, check out the findings section . This view shows the status of each finding, it’s type and ID, a link to the source code where the finding was discovered (if you added the Git URL of the repo and it is reachable from CI Fuzz). CI Fuzz also provides information to help remediate the finding. When you expand a finding in the bottom pane, it will contain 3 tabs with different information: Debug, Description, and Log. These tabs contain several pieces of information that can help you determine the root cause of the finding. | The debug tab contains the fuzz test responsible for the finding, the source line, the stack trace (if available), and the crashing input. | The description tab contains the severity score, a short description of the finding, and possibly some links to additional information about this type of finding. | The log tab content depends on the type of fuzzing that discovered the finding. If the finding is from unit fuzzing, then the output will be output directly from the fuzzer. If the finding is from Web API fuzzing, then the output will contain the API request responsible for triggering the finding. | . 5.3 Examine Coverage . To view additional details about coverage, just click Code Coverage on the left sidebar. This will show you the overall coverage and a breakdown of the coverage by file. ",
    "url": "http://localhost:4000/ci-fuzz-quick-start-cpp#5-running-the-fuzz-tests",
    "relUrl": "/ci-fuzz-quick-start-cpp#5-running-the-fuzz-tests"
  },"115": {
    "doc": "Quick Start Java",
    "title": "Quick Start Java",
    "content": "This quick start guide is intended to teach you the basics of using cifuzz with a Java project. cifuzz directly supports Maven and Gradle build systems. This guide was created using Ubuntu 20.04 x64. If you are on MacOS or Windows, you should be able to follow along without any issues. If you have not yet installed cifuzz, then first head to the installation section . ",
    "url": "http://localhost:4000/cli-quick-start-java",
    "relUrl": "/cli-quick-start-java"
  },"116": {
    "doc": "Quick Start Java",
    "title": "Table of contents",
    "content": ". | Maven . | 1. Setting Up | 2. Initialize the Project | 3. Creating a Fuzz Test | 4. Running the Fuzz Test | 5. Examine Findings | . | Gradle . | 1. Setting Up | 2. Initialize the Project | 3. Creating a Fuzz Test | 4. Running the Fuzz Test | 5. Examine Findings | . | . ",
    "url": "http://localhost:4000/cli-quick-start-java#table-of-contents",
    "relUrl": "/cli-quick-start-java#table-of-contents"
  },"117": {
    "doc": "Quick Start Java",
    "title": "Maven",
    "content": "1. Setting Up . Download or clone the following repository: https://github.com/CodeIntelligenceTesting/ci-fuzz-cli-getting-started. This repository contains several projects. For this guide, you will use the project in the tutorials/java/maven directory. Note: all cifuzz commands listed in this section should be run from the java/maven directory. 2. Initialize the Project . The first step for any project is to initialize it. Initialization means creating a configuration file, cifuzz.yaml, in the project directory and modifying your top level pom.xml file. Run the following command: . cifuzz init . When you run cifuzz init it will recognize the project as a Maven project and provide two dependencies that you should add to your pom.xml: . | jazzer-junit - this dependency enables cifuzz integration with your project | junit-jupiter-engine - this dependency ensures easy integration between your IDE and cifuzz | . After adding both dependencies, your pom.xml should look similar to: . &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.github.CodeIntelligenceTesting.cifuzz&lt;/groupId&gt; &lt;artifactId&gt;maven-example&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;maven-example&lt;/name&gt; &lt;description&gt;A simple maven-example for cifuzz&lt;/description&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.code-intelligence&lt;/groupId&gt; &lt;artifactId&gt;jazzer-junit&lt;/artifactId&gt; &lt;version&gt;0.13.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.8.8&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;report&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; . 3. Creating a Fuzz Test . The next step is to create a java fuzz test template. With one of the main goals of cifuzz being to make fuzz testing as easy as unit testing, we’ll create and then place the fuzz test in the src/test/java/com/example directory, just as we would a standard unit test. Run the following commands: . mkdir -p src/test/java/com/example cifuzz create java -o src/test/java/com/example/MyFuzzTest.java . If you open src/test/java/com/example/MyFuzzTest.java, you should see a fuzz test template. Before we write the fuzz test, take a look at the target method that we want to fuzz. It is located in src/main/java/com/example/ExploreMe.java: . package com.example; public class ExploreMe { public static void exploreMe(int a, int b, String c) { if (a &gt;= 20000) { if (b &gt;= 2000000) { if (b - a &lt; 100000) { // Create reflective call if (c.startsWith(\"@\")) { String className = c.substring(1); try { Class.forName(className); } catch (ClassNotFoundException ignored) { } } } } } } } . The main parts to focus on here is the parameters that the exploreMe method requires, int a, int b, string c. As long as we can pass the correct data types to the function, the fuzzer will take care of the rest. Now we’ll write the fuzz test. You can write or copy/paste the following into src/test/java/com/example/MyFuzzTest.java: . package com.example; import com.code_intelligence.jazzer.api.FuzzedDataProvider; import com.code_intelligence.jazzer.junit.FuzzTest; public class MyFuzzTest { @FuzzTest void myFuzzTest(FuzzedDataProvider data) { int a = data.consumeInt(); int b = data.consumeInt(); String c = data.consumeRemainingAsString(); ExploreMe.exploreMe(a, b, c); } } . A few notes about this fuzz test: . | The fuzz test is part of the same package as the target class/method. | The @FuzzTest annotation is what enables you to write fuzz tests similar to how you’d write JUnit tests. | The fuzz test must import com.code_intelligence.jazzer.junit.FuzzTest | This fuzz test uses the FuzzedDataProvider class. This is not required, but it is a convenient way to split the fuzzing input in the data variable into different data types. Here is a link to the FuzzedDataProvider class documentation if you want to view it’s other methods. | Once we have created the appropriate variables (a, b, and c) using data from the fuzzer, the fuzz test just has to call the target method (ExploreMe.exploreMe) with the fuzz data. | . 4. Running the Fuzz Test . Everything is configured and the fuzz test is created. Run the fuzz test using: . cifuzz run com.example.MyFuzzTest . After a moment you should be notified that cifuzz discovered a potential Remote Code Execution in exploreMe. Here is a snippet of the output: . &lt;snip&gt; 💥 [vibrant_cow] Security Issue: Remote Code Execution in exploreMe (com.example.ExploreMe:12) &lt;snip&gt; . 5. Examine Findings . When cifuzz discovers a finding, it stores the output from the finding and the input that caused it. You can list all findings discovered so far by running cifuzz findings. If you want to see the details of a specific finding just provide it’s name, e.g. cifuzz finding vibrant_cow. This will provide the stack trace and other details about the finding that will help you debug and fix the issue. Examining the output from cifuzz finding vibrant_cow below shows that there was unrestricted class loading based on externally controlled data. This was was triggered at line 12 in the com.example.ExploreMe.exploreMe. &lt;snip&gt; == Java Exception: com.code_intelligence.jazzer.api.FuzzerSecurityIssueHigh: Remote Code Execution Unrestricted class loading based on externally controlled data may allow remote code execution depending on available classes on the classpath. at jaz.Zer.&lt;clinit&gt;(Zer.java:54) at java.base/java.lang.Class.forName0(Native Method) at java.base/java.lang.Class.forName(Class.java:375) at com.example.ExploreMe.exploreMe(ExploreMe.java:12) at com.example.MyFuzzTest.myFuzzTest(MyFuzzTest.java:13) &lt;snip&gt; . If you examine line 12 in src/main/java/com/example/ExploreMe.java, you can see this is where it attempts to load a class based off of input data. cifuzz also stores the crashing input in a resources directory. In this example, that would be src/test/resources/com/example/MyFuzzTestInputs/vibrant_cow. This can be helpful when debugging your application. ",
    "url": "http://localhost:4000/cli-quick-start-java#maven",
    "relUrl": "/cli-quick-start-java#maven"
  },"118": {
    "doc": "Quick Start Java",
    "title": "Gradle",
    "content": "1. Setting Up . Download or clone the following repository: https://github.com/CodeIntelligenceTesting/ci-fuzz-cli-getting-started. This repository contains several projects. For this guide, you will use the project in the tutorials/java/gradle directory. Note: all cifuzz commands listed in this section should be run from the java/gradle directory. 2. Initialize the Project . The first step for any project is to initialize it. Initialization means creating a configuration file, cifuzz.yaml, in the project directory and modifying your build.gradle file. Run the following command: . cifuzz init . When you run cifuzz init it will recognize the project as a Gradle project and provide two dependencies that you should add to your build.gradle: . | com.code-intelligence:jazzer-junit - this dependency enables cifuzz integration with your project | org.junit.jupiter:junit-jupiter - this dependency ensures easy integration between your IDE and cifuzz | . After adding both dependencies, your build.gradle should look similar to: . plugins { // Apply the application plugin to add support for building a CLI application in Java. id 'application' id 'jacoco' } repositories { // Use Maven Central for resolving dependencies. mavenCentral() } dependencies { testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0' testImplementation 'com.code-intelligence:jazzer-junit:0.13.0' // This dependency is used by the application. implementation 'com.google.guava:guava:31.1-jre' } application { // Define the main class for the application. mainClass = 'com.github.CodeIntelligenceTesting.cifuzz.App' } tasks.named('test') { // Use JUnit Platform for unit tests. useJUnitPlatform() } . 3. Creating a Fuzz Test . The next step is to create a java fuzz test template. With one of the main goals of cifuzz being to make fuzz testing as easy as unit testing, we’ll create and then place the fuzz test in the src/test/java/com/example directory, just as we would a standard unit test. Run the following commands: . mkdir -p src/test/java/com/example cifuzz create java -o src/test/java/com/example/MyFuzzTest.java . If you open src/test/java/com/example/MyFuzzTest.java, you should see a fuzz test template. Before we write the fuzz test, take a look at the target method that we want to fuzz. It is located in src/main/java/com/example/ExploreMe.java: . package com.example; public class ExploreMe { public static void exploreMe(int a, int b, String c) { if (a &gt;= 20000) { if (b &gt;= 2000000) { if (b - a &lt; 100000) { // Create reflective call if (c.startsWith(\"@\")) { String className = c.substring(1); try { Class.forName(className); } catch (ClassNotFoundException ignored) { } } } } } } } . The main parts to focus on here is the parameters that the exploreMe method requires, int a, int b, string c. As long as we can pass the correct data types to the function, the fuzzer will take care of the rest. Now we’ll write the fuzz test. You can write or copy/paste the following into src/test/java/com/example/MyFuzzTest.java: . package com.example; import com.code_intelligence.jazzer.api.FuzzedDataProvider; import com.code_intelligence.jazzer.junit.FuzzTest; public class MyFuzzTest { @FuzzTest void myFuzzTest(FuzzedDataProvider data) { int a = data.consumeInt(); int b = data.consumeInt(); String c = data.consumeRemainingAsString(); ExploreMe.exploreMe(a, b, c); } } . A few notes about this fuzz test: . | The fuzz test is part of the same package as the target class/method. | The @FuzzTest annotation is what enables you to write fuzz tests similar to how you’d write JUnit tests. | The fuzz test must import com.code_intelligence.jazzer.junit.FuzzTest | This fuzz test uses the FuzzedDataProvider class. This is not required, but it is a convenient way to split the fuzzing input in the data variable into different data types. Here is a link to the FuzzedDataProvider class documentation if you want to view it’s other methods. | Once we have created the appropriate variables (a, b, and c) using data from the fuzzer, the fuzz test just has to call the target method (ExploreMe.exploreMe) with the fuzz data. | . 4. Running the Fuzz Test . Everything is configured and the fuzz test is created. Run the fuzz test using: . cifuzz run com.example.MyFuzzTest . After a moment you should be notified that cifuzz discovered a potential Remote Code Execution in exploreMe. Here is a snippet of the output: . &lt;snip&gt; 💥 [vibrant_cow] Security Issue: Remote Code Execution in exploreMe (com.example.ExploreMe:12) &lt;snip&gt; . 5. Examine Findings . When cifuzz discovers a finding, it stores the output from the finding and the input that caused it. You can list all findings discovered so far by running cifuzz findings. If you want to see the details of a specific finding just provide it’s name, e.g. cifuzz finding vibrant_cow. This will provide the stack trace and other details about the finding that will help you debug and fix the issue. Examining the output from cifuzz finding vibrant_cow below shows that there was unrestricted class loading based on externally controlled data. This was was triggered at line 12 in the com.example.ExploreMe.exploreMe. &lt;snip&gt; == Java Exception: com.code_intelligence.jazzer.api.FuzzerSecurityIssueHigh: Remote Code Execution Unrestricted class loading based on externally controlled data may allow remote code execution depending on available classes on the classpath. at jaz.Zer.&lt;clinit&gt;(Zer.java:54) at java.base/java.lang.Class.forName0(Native Method) at java.base/java.lang.Class.forName(Class.java:375) at com.example.ExploreMe.exploreMe(ExploreMe.java:12) at com.example.MyFuzzTest.myFuzzTest(MyFuzzTest.java:13) &lt;snip&gt; . If you examine line 12 in src/main/java/com/example/ExploreMe.java, you can see this is where it attempts to load a class based off of input data. cifuzz also stores the crashing input in a resources directory. In this example, that would be src/test/resources/com/example/MyFuzzTestInputs/vibrant_cow. This can be helpful when debugging your application. ",
    "url": "http://localhost:4000/cli-quick-start-java#gradle",
    "relUrl": "/cli-quick-start-java#gradle"
  }
}
